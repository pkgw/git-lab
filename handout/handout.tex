\documentclass[letterpaper, 12pt, titlepage, twoside]{article}
\input setup

\begin{document}

% Title page -- with temporary margins to keep everything centered.
\newgeometry{margin=1in}
\begin{titlepage}
\title{A Laboratory Introduction to {\git} and {\github}}
\author{P. K. G.~Williams (\href{mailto:peter@newton.cx}{peter@newton.cx})}
\date{\today \\ version \t{\gitversion}}
\maketitle
\end{titlepage}
\restoregeometry


% A silly colophon page. This is mainly about having the real content start on
% a right-hand page as is customary.
\thispagestyle{empty}
\leavevmode
\vfill
\begin{flushright}
  Typeset in EB~Garamond and Adobe Source Code Pro using \LaTeX.
\end{flushright}
\newpage


\section*{Introduction\markboth{Introduction}{}}

Welcome to the \git\ lab! This manual aims to help you learn the fundamentals
of this awesome tool by walking you through its everyday functionality. You'll
also learn about the popular commercial website \github, and how the two fit
together.

\xnote{This is an example marginal note!}

This manual includes a lot of marginal notes\x. They are intended to provide
extra context and information for reference, but you don't need to read them
for the core lab activities.

\xnote{Learning \git\ is like learning an instrument or a language. There are
  certain concepts to master, but there's also just an element of practice.
  Unix pros talk about \i{finger memory}: you need to type a command a few
  hundred times to start really using it fluently.}

Here are some basic guidelines for this lab:

\begin{itemize}
\item \i{We strongly recommend that you actually type out the commands shown
  here}, \x and not just read the commands passively.

\item \i{This lab is best done with a partner.} However, please try to switch
  off between who's ``driving'' the keyboard and who's watching and
  commenting.

\item \i{Ask for help!} That's the whole point of doing this lab as a group
  instead of on your own. If you and your partner get stuck, trying asking the
  group next to you, or Google.

\item Of course, with computers sometimes things go wrong even if you've done
  everything right --- if you see a truly strange error message, particularly
  one associated with a non-\git\ command, get the attention of an expert.
\end{itemize}

\subsection*{Notation in this manual}

Important terms will be introduced in \i{italics}. Computer-y words will be
written in a monospace font \t{like} \t{this}. Commands to type in the
terminal in are presented with commentary like so:

\typeone{echo hello world}{\b{Say hello.}}

Don't type the dollar sign, which indicates the terminal prompt.

Often you'll have to fill in part of a command yourself. Substitute \p{sample
  text} with a value that you choose or figure out for yourself. For instance:

\nopagebreak

\begin{typeme}
echo "\p{the current year}" & What's printed in this manual. \\
echo "\the\year" & What you actually type.
\end{typeme}

Don't type the braces!

\xnote{Take special care with punctuation and similar letters --- command-line
  interfaces are finicky. The characters \fbox{\t{'}} (single vertical quote),
  \fbox{\t{`}} (backtick), and \fbox{\t{"}} (double vertical quote) may be
  similar but they are all interpreted differently by the computer. Likewise
  for \fbox{\t{l}} (the letter ell), \fbox{\t{1}} (the digit one),
  \fbox{\t{|}} (pipe symbol), and so on.}

With \x the exception of the leading dollar signs and \p{sample text}, you'll
get your best results if you \i{type every command exactly as shown in this
  manual}.

Other actions you that you should perform on your computer are typeset like
so:

\begin{noncli}
  Start your code editor.
\end{noncli}

This manual also includes questions to can check your understanding. Let's
start simple:

\fillme{0.6in}{What is your name?}

No one's going to grade you, but it will help learning if you actually think
about these questions and write down your answers!


\mypart{Command-Line Basics}

\section{git config}

\xnote{The \git\ program that you run from the terminal is a sort of ``Swiss
  Army knife'' tool that provides many \i{commands} that do all sorts of
  different things. The command that sets up configuration is (quite sensibly)
  \cmd{config}.}

Before \x we really get started, we need to set up some important
configuration. We can do this with the \git\ program itself. Run these
commands:

\begin{typeme}
git config --global color.ui auto & \b{Use colors in printed output.} \\
git config --global alias.ci commit & A useful shorthand. \\
git config --global alias.s status & A useful shorthand.
\end{typeme}

\xnote{\git\ will embed your name and email address in all of its logs of your
  activity, so it's important to declare them! The values you enter here will
  be preserved permanently. For email, it's best to use a long-lived, public
  address.}

For \x the next two, remember to replace the sample text with real answers.
Don't type the braces, but do type the double quotes.

\begin{typeme}
git config --global user.name "\p{your name}" & Tell \git\ your name. \\
git config --global user.email "\p{your email address}" & Tell git your email.
\end{typeme}

Now we can get started for real!


\section{git clone}

\xnote{There are two \git\ commands to set up a repository: \cmd{init}, which
  creates a new, empty repository; and \cmd{clone}, which duplicates an
  existing one. We use the latter so that we have some files to work with
  right off the bat.}

We'll \x get started by setting up a \i{git repository} (``repo'') to play
with. This is the directory containing your actual content (\ie, files) as
well as \git's supporting data.

\begin{typeme}
cd & Move to home directory. \\
mkdir gitlab & Create work directory. \\
cd gitlab & Move into it. \\
git clone https://github.com/pkgw/bloomdemo.git & \b{Clone an existing repo.}
\end{typeme}

What file(s) did \git\ just create?

\begin{typeme}
ls & Examine files.
\end{typeme}

Let's navigate into this directory and examine its contents.

\xnote{The code here uses a tool called a \i{Bloom filter} to let you check
  whether a words is found in the English dictionary. Bloom filters make
  mistakes, but in a one-sided way: if a word is in the dictionary, a Bloom
  filter will never say that it isn't; but sometimes a Bloom filter will think
  that a word is in the dictionary when it really isn't. Why would you want that
  behavior? Bloom filters are much faster than filters that are always correct,
  and sometimes it's good to trade accuracy for speed. Don't worry: the details
  aren't important here. If you have extra time and are curious, read the file
  \t{bloom.py}.}

\x \begin{typeme}
cd bloomdemo & Enter repository directory. \\
ls & Examine files again. \\
ls -la & Detailed listing of files.
\end{typeme}

By the way, in the final command above, the letter after the dash is an ell,
not a one.

\fillme{0.4in}{The detailed file listing should reveal a hidden directory,
  used by \git\ to store its supporting data. What is this directory called?}

Your cloned repository is both self-contained and self-sufficient. You can do
anything you want to it without having to talk to \github\ again (without even
needing an internet connection, in fact), and nothing you do will affect the
\github\ version unless you explicitly attempt to synchronize the two.

You can see a gory listing of \git's housekeeping files with:

\typeone{find . -print}{\b{Print all file names.}}

Finally, to prepare for some concepts that come later in this lab, run this
command:

\typeone{git branch print-my-name}{We'll come back to this later.}

\subsection*{Testing your Python}

The repository we cloned is named \s{bloomdemo}. Let's learn a bit more about
it:

\typeone{cat README}{\b{Print the bloomdemo repository's \t{README}.}}

The \s{README} says that this repository contains Python code. Before you go
any farther, let's check that your Python installation works:

\typeone{./chkdict barn bern birn born burn}{\b{Check reality of words.}}

When you run the above command, you should get a report about whether certain
words are in the dictionary. You should \i{not} get any big honking error
messages. If you do, please consult with an expert.


\section{git status, git checkout}

\xnote{Now, in some circumstances HEAD isn't chronologically the most recent,
  but for now that's the best way to think about it.}

Fundamentally, \x all \git\ does is track changes to the files in your
repository. It compares the files on disk, the \i{working tree}, with a recent
snapshot of their contents. \git\ stores many of these snapshots, each of
which is called a \i{commit}. The most ``recent'' snapshot, in a sense, is
known as the \i{HEAD} commit or just HEAD.

\xnote{Not sure how to open files in a code editor? Ask your partner or one of
  the experts!}

Let's see how this process works.

\x
\begin{noncli}
  Open the file \s{chkdict} in your code editor. Find the line that includes
  the words \t{"MIGHT BE"}. Edit it to add the words \t{"... or it might not"}
  within the quotation marks. Save the file when done.
\end{noncli}

If everything worked, the output of the program should change when you rerun
the program:

\begin{typeme}
./chkdict barn bern birn born burn & Check that change stuck.
\end{typeme}

Next we'll use \cmd{status} to learn about \i{local modifications} to the
working tree compared to the most recent snapshot:

\typeone{git status}{\b{Check modification status.}}

\xnote{Newer versions of \git\ use \cmd{restore} instead of \cmd{checkout}
  here. The new name was created because \cmd{checkout} did two very different
  jobs, as we'll see later. But not that many computers have a new enough
  version of \git\ installed just yet.}

The \cmd{status} \x command prints out several pieces of information. Ignore most
of them for now. But you should see \git\ highlight that \t{chkdict} has been
modified. It should also tell you how to discard your changes if you decide
you don't like them. You can do this with the \cmd{checkout} command:

\begin{typeme}
git checkout chkdict & \b{Discard changes to chkdict.} \\
./chkdict \p{some words} & Check that change is gone. \\
git status & Check modification status.
\end{typeme}

\xnote{If your working directory isn't clean, then it is, appropriately,
  \i{dirty}.}

Your change should be gone, and \git\ should report that your working
directory is \x \i{clean}.

\fillme{0.6in}{Does \git\ go so far as to restore the modification timestamp
  of \t{chkdict}? You can use \t{ls -l} to check.}

\xnote{If you have something that already works, the chief enemy of progress
  is the fear of breaking what you do have. You will truly have mastered the
  Zen of Git when you gleefully shred your most precious files without a care
  in the world.}

Let's \x pause here. \i{The ability to discard your changes is profoundly
  important and immensely powerful.} A \i{huge} amount of progress stems from
one basic operation: ``Let's try this and see if it works.'' \textit{Git makes
  it safe to try things} because it makes it easy to revert to known-working
code.

These snapshots also mean that \git\ is a nearly disaster-proof backup tool.
If you have an up-to-date copy of your \t{.git} directory \i{somewhere}, you
can probably recover your files.

\begin{typeme}
rm dictbf.dat.gz & Remove important file. \\
./chkdict barn bern birn born burn & Check that program fails. \\
git status & Check modification status. \\
git checkout dictbf.dat.gz & Restore deleted file. \\
./chkdict barn bern birn born burn & Check that program is healed. \\
pwd & Check your directory. \\
rm -fv *.py *.pyc *.gz *dict* README & Type carefully! \\
ls -la & Not quite everything gone. \\
git checkout . & Bring it all back. \\
ls -la & Huzzah!
\end{typeme}

\xnote{Many developers have a saying that inverts the point of view: \i{if it
    isn't in Git, it didn't happen}.}

The saved commits in the \t{.git} directory guard against many kinds of
blunders. \x When you add in \git's ability to synchronize repositories
between different computers, you get almost complete invulnerability to loss
of the data stored in the repository.


\section{git add, git commit}

If you want to protect a file, \git\ needs to be tracking it. This doesn't
happen automatically. The following commands create a new file called
\t{mynewfile} and then delete it. Because we haven't told \git\ to track
\t{mynewfile}, we cannot recover it:

\begin{typeme}
echo hello >mynewfile & Create a new file. \\
git status & Check modification status. \\
rm mynewfile & Remove it. \\
git checkout mynewfile & There's no saving that one.
\end{typeme}

\xnote{We won't go into \i{why} this two-phase approach was chosen, but there
  are good reasons.}

Commits are the way that \git\ remembers your files, so we should learn how to
make them! Making commits in \git\ is a two-step \x process. First, you have
to identify which changes you want to commit by \i{staging} them with the
\cmd{add} command. Then you actually create the new commit with \cmd{commit}.
We'll demonstrate this.

\begin{noncli}
  Open the file \s{chkdict} in your code editor and recreate the change you
  made before. Save the file when done.
\end{noncli}

\xnote{We'll see below that \cmd{add} can also teach \git\ about new files.
  This is an example of a common annoyance with \git: the same command will
  often do very different things depending on how exactly you run it.}

Now \x run these commands:

\begin{typeme}
./chkdict barn bern birn born burn & Validate your change. \\
git status & Check modification status. \\
git add chkdict & \b{Stage the change.} \\
git status & Note change in output. \\
\end{typeme}

\fillme{0.4in}{How does \git\ describe the status of \t{chkdict} after you
  have ``added'' it?}

To finalize the commit, run:

\typeone{git commit}{\b{Commit the staged changes.}}

\xnote{Generally speaking, more sophisticated and organized projects will have
  more detailed policies about what should go in each message. I find it
  helpful to identify the section or subsystem that the commit most strongly
  affects --- that's the bit before the colon --- and then tersely summarize
  what you did. Additional lines should report \i{why}. The rule of a
  gold-plated commit message is that someone knowledgeable should be able to
  recreate your changes based only on the message.}

When \x you run \cmd{commit} you will be prompted to write a \i{commit
  message}. There are no rules about the message contents, but every commit
must have one. Here, I suggest a one-line message of this form:

\hspace{3em}\t{chkdict: change the "MIGHT BE" message for fun}

You \i{also} use \cmd{add} to tell \git\ to start keeping track of a new file.

\begin{typeme}
date >mynewfile & Create a new file. \\
git status & Check modification status. \\
git add mynewfile & \b{Register it.} \\
git status & Note change in output. \\
git commit -m "\p{your message}" & Commit the staged changes.
\end{typeme}

Here we've used a new option to \cmd{commit}: the \t{-m} option, which lets
you write the commit message right on the command line. You'll probably be
mostly writing short messages, so the \t{-m} option can be a big convenience.

\fillme{1.4in}{Say you had done the above steps through \t{git add newfile}
  and then decided you actually didn't want to commit the new file. What
  command would you run to reset things? (Hint: \cmd{status} is
  informative.) What happens to \t{newfile} in this case?}

There are a couple of other ways to ``stage'' changes to be committed. For
instance, if we decide we don't want to keep \t{mynewfile} around anymore, we
need to use \cmd{rm} to register the removal:

\begin{typeme}
rm mynewfile & Remove our file. \\
git status & Check modification status. \\
git rm mynewfile & \b{Tell \git\ we want to remove it.} \\
git status & Note change in output. \\
git commit -m "\p{deletion message}" & Commit the staged changes.
\end{typeme}

\xnote{This is \underline{very} important if, for example, you accidentally
  commit a password into a repository: even if you make a commit to remove the
  information, other people can still recover your password. There are ways to
  fully delete such information, but we won't get into them here.}

An \x important point is that \i{\git\ never forgets anything, so even if you
  delete a file from a repository, its contents are still stored and
  recoverable}.

There's also a \cmd{mv} command. It's the equivalent of an \t{add} and an
\t{rm} together. Both this and \cmd{rm} will perform the specified moves
and/or removals on relevant working-tree files if they haven't already
happened.

Finally, \cmd{commit} has a useful option: the \t{-a} option, which
automatically does the equivalent of \cmd{add} on all of your modified files.
It does \i{not} auto-add untracked files in your working tree. Using the
standard Unix syntax for combining command-line options, we get a very
useful pattern, exemplified here:

\begin{typeme}
date >>README & Modify the README. \\
git commit -am "README: add a timestamp" & Add and commit.
\end{typeme}

\xnote{Most people starting out with coding and \git'ing tend to evolve
  towards writing shorter and shorter messages for larger and larger commits,
  usually converging in one large commit made at the end of the day labeled
  ``Update.'' I \i{strongly, strongly urge} you to try to get into the habit
  of committing in small chunks with thought-out log messages, even if it may
  take a while for the payoff to become clear. The fundamental reason is that
  smaller commits are easier to understand. By breaking your work into smaller
  pieces, it's easier to reason about its correctness and overall design. This
  is true both as you write new code, and as you evaluate old code --- every
  experienced programmer can tell you about revisiting \i{their own} year-old
  work and having no idea what they were thinking when they wrote it. This
  path also goes both ways: the effort that you spend reasoning about how to
  break down your code into commits will help deepen your understanding of how
  to structure software in general. The more you do it, the easier it will
  get, and the better programmer you'll be.}

Once \x you develop your finger memory, this is the quickest way to make commits.


\section{git log}

If you find yourself wanting to review your previous commits, \cmd{log} is the
command to use.

\typeone{git log}{\b{Show the commit history.}}

The \cmd{log} command will open up a ``pager'' program as described in an
Appendix. It shows you a series of commits, each associated with an author, a
date, and a message. Each commit also has a \i{commit identifier}, which is
the string of 40 random-looking characters. You should see your own recent
commits at the top of the output.

\fillme{0.4in}{On what date was the very first commit made in this repository?
  You may want to consult the table of keystrokes that control the pager on
  \autopageref{l.lesskeys}.}

\fillme{0.4in}{Find a commit whose message contains the word ``consuming.'' On
  what date was it made?}

Every distinct \git\ commit in the universe has a unique identifier. The
identifiers look random but are uniquely determined by the commit's files and
history.

\pagebreak[4]

\fillme{1.5in}{(Optional.) Commit identifiers are 40-character hexadecimal
  strings, with each character having 16 possible values (0--9, a--f). If you
  made one new commit every second, about how many Hubble times would need to
  elapse before you used all possible identifiers? The Hubble time is about
  $4.3 \times 10^{17}$~s, and $2^{10} \approx 10^3$.}

\xnote{This is an \i{enormously} important aspect of \git\ --- it makes it
  easy not just to view commits, but to understand the \i{changes} that
  happened between different commits. \github's web interface makes these
  things even easier.}

The \x \cmd{log} command can also show you which files were changed in each
commit relative to the one before. This \i{diffstat} mode shows how many lines
were added and removed from each file.

\typeone{git log --stat}{\b{Show log, with change statistics.}}

\fillme{0.4in}{In the most recent commit to modify the file \t{INSTRUCTIONS},
  how many lines were added? How many removed?}


\section{git show, git diff, git grep}

\xnote{The diff format is yet another convention that shows up throughout the
  Unix ecosystem.}

The \x command \cmd{show} will show the set of changes associated with a
commit in \i{diff format}. It should be fairly intuitive to grasp, especially
with the helpful colorful highlighting that \git\ gives you:

\typeone{git show 09933f}{\b{Show the named commit in the pager.}}

\xnote{In any given project, five or six hexadecimal digits is almost always
  enough to uniquely name a commit. Optional exercise: how many different
  combinations of six hexadecimal digits are there?}

Above, \x we've named a commit based on the beginning of its hexadecimal
identifier. You already know the name of another commit: HEAD.

\typeone{git show HEAD}{Show your most recent commit.}

The diff for this commit is fairly simple since it was a trivial example you
authored just a little while ago.

\fillme{0.4in}{Use \cmd{log} to find the commit that adds code that uses
  \s{gzip} to compress the Bloom filter data file, then use \cmd{show} to view
  the commit diff. What Python module is needed to add \s{gzip} support?}

\subsection*{The Bloom Filter False-Positive Rate}

Rather than showing an existing commit, the \cmd{diff} command shows the
difference between your working tree and \i{the staged set of changes} ---
\i{not} the most recent commit. We'll demonstrate this with a longer example.

\begin{noncli}
  Open the \t{chkdict} file in your code editor.
\end{noncli}

\xnote{The false-positive rate is the average frequency with which the
  Bloom filter will say that a word \i{is} in the dictionary when it really
  \i{isn't}. If \t{fp = 0.01}, the filter will think that 1\% of non-words are
  actually words, on average. If \t{fp = 0.9}, the filter will think that 90\%
  of non-words are actually words. This parameter is useful because there's a
  tradeoff: filters with larger false-positive rates are less accurate but
  more efficient.}

Towards \x the end of the file you will see that it sets a variable named
\t{fp}. This variable is the ``false-positive rate'' for the program's Bloom
filter.

\begin{noncli}
  Modify \t{chkdict} to print out \t{fp} before it reports the filter results
  for each word. To do this you need to add one line of code to the
  \t{chkdict} file. Save the file when done.
\end{noncli}

\begin{typeme}
./chkdict \p{some words} & Check everything works. \\
git diff & \b{Review unstaged changes.} \\
git add chkdict & Stage for committing. \\
git diff & Review unstaged changes.
\end{typeme}

\fillme{0.4in}{What is the reported false-positive rate?}

But wait a minute! A false-positive rate is a probability. Your program should
have printed out a negative number, which is not a legal probability.

\xnote{Technically \cmd{grep} and the search feature of \t{less} use a Unix
  formalism called \i{regular expressions} or \i{regexes}. These are powerful
  and cool constructs, but for our purposes, you can just type what you're
  looking for.}

The false positive rate came from a function called \t{fprate}. You can use
\x \cmd{grep} to locate its definition: this command searches for a string in the
working tree files.

\typeone{git grep 'def fprate'}{\b{Locate instances of ``fprate''.}}

The repository that you checked out has had a bug intentionally inserted into
this function.

\begin{noncli}
  Open the file identified by \cmd{grep}. Find the definition of the
  \t{fprate} function. Remove the bug according to the instructions in the
  file.
\end{noncli}

\typeone{./chkdict \p{some words}}{Check everything works.}

\fillme{0.4in}{What is the correct false-positive rate?}

\fillme{0.4in}{(Extra credit.) Use \cmd{checkout} to discard your fix, then
  the new command \cmd{blame} to identify the commit that introduced the bug.
  Which one was it? When done, re-fix the bug. The additional new command
  \cmd{help~blame} may come in handy.}

The next set of commands will work through some of the permutations of having
both staged and unstaged modifications in your working tree. Recall that above
we ran \cmd{add} on our change to make \t{chkdict} print out the
false-positive rate, but we didn't run \cmd{commit}.

\begin{typeme}
git status & Check modification status. \\
git diff & Review unstaged changes. \\
git commit & Commit staged changes.
\end{typeme}

\fillme{0.4in}{What change(s) was/were just committed?}

\fillme{0.6in}{If you were to run \cmd{diff} now, after the \cmd{commit}, what
  would you see? Try to guess the answer without just running the command!}

\begin{typeme}
git diff & Review unstaged changes. \\
git add \p{remaining file(s)} & Stage for committing. \\
git diff --staged & \b{Review staged changes.} \\
git commit & Commit staged changes. \\
git status & Check modification status.
\end{typeme}

\xnote{This contrasts with plain \cmd{diff}, which examines the differences
  between the \i{working tree} and the \i{staged changes}.}

Here, \x \cmd{diff -{}-staged} is a different mode that examines the
differences between the staged changes and HEAD. If everything has gone well,
you'll have a clean working tree, a new feature in \t{chkdict}, and a fixed
bug. You can now muck about with the working tree however you want, confident
that your important fixes won't be lost.

\begin{typeme}
pwd & Double-check your directory. \\
rm -fv *.py *.pyc *.gz *dict* README & Type carefully! \\
ls -l & Confirm file removal. \\
git checkout . & Bring them all back. \\
./chkdict \p{some words} & Verify correct FP rate is produced.
\end{typeme}


\mypart{Collaboration: Foundations}

\section{git branch, git checkout (redux)}

\xnote{A commit name is all you need to reconstruct the entire project history
  back to its inception: the named commit embeds the unique identifier of its
  parent(s), which embeds the identifier of \i{its} parent(s), and so on. A
  branch's \i{history} is the set of all commits that have gone into it.}

You \x were just told that in \git, a ``branch'' is just name that refers to
some specific commit, the \i{branch head}. You can store data for many
different branches at once, but there is only one \i{current branch}: the
current branch is the one that the working tree and HEAD are synchronized
with. The \cmd{branch} command prints out the names of the branches in your
repository:

\typeone{git branch}{\b{List branches.}}

The current branch is denoted in the output of \cmd{branch} with an asterisk.

\fillme{0.4in}{Our repository has only one branch. What is its name?}

\xnote{One of the reasons that \git\ is so reliable is that commits involve
  \i{appending} new information to the repository but almost no \i{rewriting}
  of existing information, which is generally more dangerous. When it does
  rewrite a file, like the branch head file, the operation is isolated and
  minimal. This is a design practice to keep in mind when writing your own
  data-processing tools.}

When \x you run \cmd{commit}, \git\ creates a new commit in its database, then
updates the the current branch to point to that new commit. The current
identity of the branch head is stored in a simple text file:

\begin{typeme}
cat .git/refs/heads/master & \b{Manually print the master branch commit id.} \\
cat .git/HEAD & Manually print out the branch that HEAD references.
\end{typeme}

Creating new branches is simple. In fact, we've already done it --- remember how
we ran \cmd{branch print-my-name} back when you checked out the repo? Now we'll
follow up on that and \i{switch branches} to activate it with \cmd{checkout} ---
another case of one command doing double duty, like \cmd{add} before. If you
have any uncommitted changes in your working tree, commit them or discard them
before running the \cmd{checkout} command --- otherwise you may get errors.

\xnote{\normalfont In newer versions of \git, this use of \cmd{checkout} is
  superseded by \cmd{switch}.}

\begin{typeme}
git status & Check modification status. \\
\x git checkout print-my-name & \b{Switch to \t{print-my-name} branch.} \\
git branch & List branches. \\
./chkdict \p{some words} & Verify that FP rate is not printed.
\end{typeme}

\xnote{If you had any uncommitted changes, \cmd{checkout} would have either
  preserved them or refused to run if it couldn't.}

Here, \cmd{checkout} has \x done two things: it's updated information to say
that the current branch is now the one named \s{print-my-name}, not
\s{master}, \i{and} it's synchronized your working tree to match
\s{print-my-name}.

\fillme{0.4in}{Use \cmd{log} to look at the history of your current branch. The
  commits that you made in Part~1 shouldn't show up. Have they been lost?}

Let's create a commit on this new branch. We can do so using the same commands
we've been using all along --- because we've changed the active branch to
\s{print-my-name}, that's the one that will be updated, not \s{master}.

\begin{noncli}
  Edit the top of the \t{chkdict} to add a line that prints your name after
  all of the \t{import} statements. Save the file when done.
\end{noncli}

Below, we've started assuming that you're getting the hang of things and don't
need to see every \cmd{add} and \cmd{commit} command written out.

\begin{typeme}
\p{review and commit your change} & Commit your change. \\
git log --oneline & \b{Summarize history for current branch.} \\
git log --oneline master & Summarize history for master branch. \\
git checkout master & Switch to master. \\
./chkdict \p{some words} & Verify that FP rate is printed. \\
git checkout print-my-name & Switch to print-my-name. \\
./chkdict \p{some words} & Verify that your name is printed.
\end{typeme}

We've also slipped in another argument to \cmd{log}, called \s{-{}-oneline},
that produces a terser form of output.

You should see that the two branches start out with the same history (at the
bottom of the log listings), but then \i{diverge}: they have commits in
common, but both branches include commits that the other doesn't.


\section{git merge}

\xnote{Recall that \s{master} contains your change to print the correct Bloom
  filter false positive rate, while \s{print-my-name} doesn't, because we
  started it from the originally cloned snapshot. Instead, \s{print-my-name}
  has a change to print out your name in the \t{chkdict} program.}

The \x \cmd{merge} command automates the process of merging one branch into
another. Here we'll merge your \s{print-my-name} branch into your \s{master}
branch.

\begin{typeme}
git checkout master & Switch to master. \\
git merge print-my-name & \b{Merge this branch into master.} \\
\end{typeme}

The \cmd{merge} command will prompt you to write a message for the merge
commit. You can usually just use the default.

Running the merged code should demonstrate the effects of both sets of
changes:

\typeone{./chkdict \p{some words}}{Verify that both your name and FP rate are printed.}

This merge could happen automatically because the two sets of changes \i{did
  not edit the same part of the same file}.

\subsection*{Resolving Merge Conflicts}

If two different branches \i{do} modify the same part of the same file in
different ways, you have a dreaded \i{merge conflict}.

\xnote{Things are a little bit simpler than you might fear since the various
  commands will tell you the necessary steps as you go through them.}

If a conflict arises, \git\ leaves your working tree in a special funky state.
The conflicting files have special markers inserted to point out where the
conflicts are. \x You must decide how to resolve the conflicts, edit the files
to implement the resolution, mark the files as dealt with using \cmd{add}, and
then finally \cmd{commit} when everything is fixed.

We'll work through a merge conflict using some secret branches that came along
with our clone:

\begin{typeme}
git branch conflict-demo origin/master & New branch with pristine files. \\
git checkout conflict-demo & Switch to \t{conflict-demo} branch. \\
git show origin/goodbye-option & View changes in the specified branch. \\
git show origin/no-skipmisses-option & Likewise.
\end{typeme}

Now let's try merging both branches into \s{conflict-demo}:

\begin{typeme}
git merge origin/no-skipmisses-option & Merge in \t{no-skipmisses-option}. \\
git merge origin/goodbye-option & Likewise.
\end{typeme}

At this point, \git\ should report a conflict. The output of the commands
isn't incredibly clear on this point, but both branches modified the same
portion of the \t{chkdict} file, so \git\ doesn't know how to proceed.

\typeone{git status}{Report merge/conflict state.}

Behind the scenes, \git\ has edited the file \t{chkdict} and added \i{conflict
  markers} indicating the problematic region that was edited in both branches.
These consist of a long row of ``\t{<<<<}'', the final text found in one
branch, then ``\t{====}'', the final text from the other branch, and finally
``\t{>>>>}''.

\begin{noncli}
  Open up \t{chkdict} in your code editor and search for these conflict
  markers.
\end{noncli}

\xnote{The example here tries to keep the conflict minimal. One branch adds a
  command-line option, and another branch removes one, so they both edit the
  same stanza of option-handling code at the beginning of \t{chkdict}. To
  resolve the conflict, you first have to decide what the merged code
  \i{should} do --- it seems clear that it should accept the new argument and
  remove the old argument. You then need to \i{implement} that solution by
  editing the code. To implement the solution you should use the sample text
  from the two branches as a reference, but the best implementation might not
  look exactly like \i{either} version. }

Your \x mission to find \i{all} conflict markers and edit the files to somehow
do what \i{both} branches intended.

\begin{noncli}
  Resolve the conflict in \t{chkdict}. Save your work.
\end{noncli}

After you're done, all of the conflict markers should be gone from your files.
You can then \cmd{add} and \cmd{commit} as usual --- \git\ uses an internal
flag to realize that this commit represents a merge and not just a regular
commit.

\begin{typeme}
git add chkdict & Stage the fix. \\
git diff --staged & Examine the changes of the final merge. \\
git commit & Commit the fix. \\
git log & Review commit history.
\end{typeme}

\fillme{1.5in}{What does the commit history of the \t{conflict-demo} branch now
  look like, as a graph?}

\subsection{Manipulating Branches}

The \cmd{branch} command provides tools for manipulating branches. You can do
things like rename them, copy them, and so on.

A common workflow is to create a new branch for each feature that you work on
--- called a ``feature branch.'' Once the feature branch is merged into the
\s{master} branch, you can tidy things up by deleting it:

\typeone{git branch -d print-my-name}{Delete this branch.}

\xnote{You can use the \t{-D} mode if you're sure that it's safe to delete a
  branch.}

The \x \t{-d} mode of \cmd{branch} won't let you delete a branch unless
\git\ is confident that the commits of that branch are replicated elsewhere.


\mypart{Collaboration: GitHub}

\section{git remote, git fetch}

\xnote{Remotes can be in a different directory on the same machine, or
  accessible over the network using any of several protocols. The simplest way
  to collaborate using \git\ is to set up a central repository on the network
  that everyone can push to --- which is exactly what
  \href{https://github.com/}{GitHub} does and why it's so popular. It bears
  emphasizing, however, that a key advantage of \git\ is that if
  \href{https://github.com/}{GitHub} were to disappear tomorrow, we wouldn't
  lose any data, because each repository is self-sufficient, and by setting up
  new remotes we could start collaborating again almost seamlessly.}

Each \git\ repository stores a list of other repositories that it knows about,
known as \i{remotes}. You can download updates from remotes and \i{push}
updates to them. Every cloned repository starts with a remote called
\s{origin}, which you've probably been seeing mentioned by various tools over
the course of the lab.

You can learn about your remotes with the \cmd{remote} command.

\begin{typeme}
git remote & \b{List named remotes.} \\
git remote show origin & \b{Show details about \t{origin}.}
\end{typeme}

Each remote is associated with \i{remote branches}, which the \cmd{remote
  show} command just listed for us. The \cmd{branch} command will also list
them if you give it the \t{-a} (``all branches'') option:

\typeone{git branch -a}{\b{Show all branches.}}

You can't make commits on these branches yourself. However, you can download
updates from the remote with the \cmd{fetch} command. We can run it here, but
since I haven't craftily updated \s{origin} since this lab started, all you'll
see is silence, indicating that there are no new commits:

\typeone{git fetch origin}{\b{Update remote branches for origin.}}

\subsection*{Linking With Your GitHub Account}

\xnote{The key thing about a fork is that you can do work on my code without
  needing to ask me for permission to start making changes. If you later want
  to submit your changes, the two repositories will nonetheless share a common
  \git\ history so that they can be merged easily.}

We'll \x now get your repository talking to your GitHub account. First, we need
to \i{fork} --- duplicate --- the origin repository.

\begin{noncli}
  Navigate your browser to \url{https://github.com/pkgw/bloomdemo/}. Click the
  ``Fork'' button at the top-right of the screen. Once you’re looking at your
  fork, click the “Clone or Download” button and copy the clone address to
  your computer’s clipboard.
\end{noncli}

Now we'll tell your repo about your fork on GitHub, registering it as a remote
named \s{mine}:

\begin{typeme}
  git remote add mine \p{GitHub clone address} & Register a new remote \\
  git fetch mine & Pull down its current status
\end{typeme}


\section{git push}

To share changes we \i{push} them to a remote. We'll create yet another branch
with some quasi-nonsense changes:

\begin{typeme}
git branch graduation origin/master & New branch with pristine files. \\
git checkout graduation & Switch to \t{conflict-demo} branch. \\
mkdir alumni & Make a directory. \\
date >alumni/\p{your-github-username}.txt & Create your very own file. \\
git add alumni & Register new directory with \git. \\
git commit -m "Git graduation." & Commit
\end{typeme}

\xnote{Of course, \cmd{push} also uploads all of the needed backing data as
  well.}

The \x command \cmd{push} copies a branch from your local repository to a
remote. The syntax with a colon shown below can be used to change the name
that the branch will be given on the remote.

\begin{typeme}
git branch -a & List all branches. \\
git push mine graduation & \b{Publish the changes.} \\
git push mine master:experiments & Publish our main work as \t{experiments}. \\
git branch -a & List all branches. \\
git remote show mine & Show details about \t{mine}.
\end{typeme}

\fillme{0.4in}{What's different the second time you run \cmd{branch~-a}?}

You'll see that \git\ prints some messages about creating a pull request.
We'll ignore them for now.

\begin{noncli}
  Reload the GitHub webpage for your fork of the \s{bloomdemo} repository. In
  the ``Branch:'' dropdown menu, you should see your new \s{graduation}
  branch. Click on the commit message (``Git graduation.'') to see your change
  as displayed by GitHub.
\end{noncli}

Your changes are now available to the wide world!

\subsection*{Issuing a Pull Request}

\xnote{Really, it would be more accurate to call them \i{merge requests}.
GitLab.com is a service very similar to GitHub that does this.}

If you're just working on a personal project, GitHub already adds value: above
all else, it backs up your repository offsite. Where it really shines,
however, is how it enables decentralized development. Specifically, GitHub
\i{pull requests} (PRs) \x let you submit changes to repositories that you
don't own.

\begin{noncli}
  Click the big green ``Compare \& pull request'' button associated with your
  \s{graduation} branch. You can attach a message to your pull request --- in
  normal usage, this would summarize what changes are in your branch, and why.

  Once the first few pull requests arrive, the lab leader will demonstrate how
  they are reviewed and handled. In the meantime, you are encouraged to click
  around the different elements of the GitHub PR user interface!
\end{noncli}


\section{git pull}

There is a \cmd{pull} command that somewhat mirrors \cmd{push}. But really,
\cmd{pull} is just a combination of \cmd{fetch} and \cmd{merge}.

\begin{noncli}
  Wait for the instructor to merge a few pull requests into the master
  repository.
\end{noncli}

\xnote{It can be tricky to merge changes if your local tree is dirty. Before
  pulling, we recomend doing a \cmd{status} and cleaning up any uncommitted or
  unstaged changes.}

Now \x that your \s{origin} repository has seen some changes, let's incorporate
them locally:

\begin{typeme}
git checkout master & Switch to \t{master} branch. \\
git pull origin & Fetch and merge any changes from \s{origin}. \\
ls alumni & See who's graduated!
\end{typeme}

\subsection*{Grand Finale}

Having successfully uploaded our work to the cloud, we can now shred our local
files without worrying.

\begin{typeme}
cd .. & Move to \t{gitlab} directory. \\
pwd & Confirm your directory. \\
rm -rfv bloomdemo & Destroy all of your work! \\
ls -la & Confirm it's gone. \\
git clone https://github.com/pkgw/bloomdemo.git & Clone the main repository. \\
cd bloomdemo & Move into it. \\
git remote add mine \p{GitHub clone address} & Register our fork. \\
git branch -a & List all branches. \\
git fetch mine & Fetch our fork. \\
git branch -a & List all branches. \\
git merge mine/experiments & Restore our changes. \\
./chkdict \p{some words} & Confirm our changes.
\end{typeme}

With a few short commands, you were able to recover the work that you did
during this lab --- not just the files themselves, but the \i{history} of what
you did to them --- even though we completely erased the directory in which
you did all of the work. I hope you're impressed!


\section*{Recap}

That's the end of the lab! What should you take away from this all?

\begin{itemize}
\item From one angle, \git\ is an excellent \i{backup tool} for your files.
\item From another, it's a \i{freedom tool} that lets you experiment in your
  projects, secure in the knowledge that you can reset things to a known-good
  state if you decide that you messed up.
\item It's also an amazing \i{collaboration tool} that provides a tractable
  way for groups of people to work together on projects in a decentralized
  manner.
\item It is also, admittedly, a \i{complicated tool} with many esoteric
  features and a sophisticated underlying theoretical model. We've barely
  scratched the surface of its capabilities.
\end{itemize}

If you don't want to be chained to a paper copy of this lab manual, is there
an electronic form? There is, and it's tracked in \git, of course:

\bigskip
{\large\centering\url{https://github.com/pkgw/git-lab}\par}


\newpage

\section*{Appendix: Unix Help\markboth{Unix Help}{}}

To learn about command-line programs in Unix operating systems, you can try
reading their ``manual page''s with the \t{man} command:

\typeone{man find}{\b{Learn about \t{find}.}}

When you run \t{man}, you enter a special subprogram called the \i{pager},
described in the next Appendix.
The \t{man} program has its own manual page:

\typeone{man man}{Learn about \t{man}.}

Unix manual pages are notoriously uneven in their quality. This is especially
true regarding \git\ itself, unfortunately. Google is often a better resource
for beginners. The information on the
\href{http://stackexchange.com/}{StackExchange.com} family of websites is
usually very helpful.


\newpage

\section*{Appendix: The Pager, “less”\markboth{The Pager, “less”}{}}

\xnote{The search and filter commands in \t{less} use a special formalism
  called \i{regular expressions} or \i{regexes} for matching text. In general,
  you can just type what you're looking for and the right thing will happen.
  \i{Many} Unix tools use regexes; they are just one of the many interlocking
  technologies that constitute the overall Unix ecosystem.}

The \i{pager} is a special Unix program for navigating lengthy textual
output. It offers many more features than the bare terminal. Because \t{man},
\git, and many other Unix tools use it extensively, it is valuable to learn a
bit about it. Different programs can do the job of the pager, but by default
your system uses a Unix command called \t{less}.

Pager programs come from a time before the scrollbar was even invented. When
using \t{less}, you should \b{not} scroll your terminal window, because it won't
interact well with \t{less}'s internal scrolling. Instead, navigate using the
keyboard --- \x \t{less} is controlled by commands that are mainly single
keystrokes. Some of these keys are:

\begin{center}
\label{l.lesskeys}
\begin{tabular}{>{\ttfamily}cl}
\rmfamily\i{Key} & \i{Effect} \\ \hline
q & Quit the pager. \\
\rmfamily(Arrow keys) & Navigate as you'd expect. \\
\rmfamily(Spacebar) & Go forward a page. \\
b & Go backwards a page. \\
< & Go to the top of the file. \\
> & Go to the bottom of the file. \\
/ & Search (type in query, then hit Enter). \\
n & Go to next search result. \\
N & Go to previous search result. \\
\& & Filter (type in query, then hit Enter). \\
h & Print help information.
\end{tabular}
\end{center}

When in doubt, just press \fbox{\t{q}} to quit the pager and return to your
main terminal prompt.

\xnote{Long-time Unix users might be used to paging files with the \t{more}
command. The symmetry in the names is not accidental --- \t{less} is \t{more}!}

\x You can run the \t{less} pager program like any other Unix command if you want
to read a file right in your terminal:

\typeone{less README}{\b{Page the file \t{README}.}}


\newpage

\section*{git Command Quick Reference\markboth{Quick Reference}{}}

There are many commands that are not listed, and all of these commands can do
much more than is given in the summaries below.

\begin{center}
\begin{tabular}{>{\ttfamily}ll}
\rmfamily\i{Command} & \i{Purpose} \\ \hline
git add \p{files} & Stage files for committing, or register new files. \\
git branch \p{name} \p{initial} & Create a new branch pointing at \s{initial}. \\
git checkout \p{branch} & Switch to a new branch. \\
git checkout \p{file} & Restore a file to its HEAD state. \\
git clone \p{URL or path} & Clone an existing repository. \\
git commit & Make a new commit. \\
git diff & Show changes between working tree and staged changes. \\
git diff --staged & Show changes between staged changes and HEAD. \\
git fetch & Fetch updates from a remote. \\
git grep \p{regex} & Search for text in the repository contents. \\
git init & Create a new empty repository. \\
git log & Show commit logs. \\
git merge \p{branch} & Merge another branch into the current one. \\
git mv \p{old} \p{new} & Rename a \git-tracked file. \\
git pull & Combination of \t{fetch} and \t{merge}. \\
git push & Publish updates to a remote. \\
git rm \p{file} & Delete a \git-tracked file. \\
git show \p{commit} & Show the changes in a commit. \\
git status & Report status of the working tree.
\end{tabular}
\end{center}

\end{document}
