\documentclass[letterpaper,12pt,titlepage,twoside]{article}
\input setup

\title{A Laboratory Introduction to \git}
\author{P. K. G. Williams (\href{mailto:peter@newton.cx}{peter@newton.cx})}
\date{\today \\ version \t{\gitversion}}

\begin{document}
\maketitle

\section*{Introduction\markboth{Introduction}{}}

Welcome to the \git\ lab! This manual aims to help you learn the fundamentals
of this awesome tool by walking you through some exercises that demonstrate
its everyday functionality. Along the way we'll discuss some of its underlying
principles and its connection to the rest of the Unix ecosystem too. We should
note that we're assuming that you've already been given a broad overview of
what \git\ is, and why you might want to use it.

Learning \git\ is like learning an instrument, or a language. There are
certain concepts to master, but there's also just a lot of practice involved:
repeating certain motions so that they become automatic. When it comes to
computers, Unix pros talk about \i{finger memory}: I can type out \t{git
  commit -am} in my sleep. Of course, there's also the deeper appreciation of
the underlying concepts and esoteric possibilities that you gain as you use a
tool more and more. My assertion to you is that \i{time spent practicing
  \git\ will more than repay itself in the future}. If you're just starting
out as a programmer (\ie, you've written less than 100,000 lines of code or
so), some of its advantages are a bit hard to grasp; for what it's worth, the
developer site \href{https://github.com/}{GitHub} has more than 4.5 million
users and 6 million \git\ repositories.

\i{This lab is best done with a partner.} Real-deal education research shows
that it's much faster for you to learn something when talking it over with a
partner rather than just staring at it by yourself. Getting back to the finger
memory thing, though, please try to switch off between who's ``driving'' the
keyboard and who's watching and commenting. It really does make a difference!

If you and your partner get stuck on something, trying asking the group next
to you, or Google. Your lab assistants are happy to help you out, of course,
but you'll learn more if you spend some time trying to solve problems on your
own. That being said, with computers sometimes things go wrong even if you've
done everything right --- if you see a truly strange error message,
particularly one associated with a non-\git\ command, it's probably better to
summon the lab assistants sooner rather than later. Deeper conceptual
questions (``why'' rather than ``how'') are also good to bring to the
assistants.


\subsection*{Notation in this manual}

Important terminology will be introduced in \i{italics}. Computer-y words will
be written in a monospace font \t{like} \t{this}. Commands that you should
type in a terminal in are presented with commentary this way:

\typeone{echo hello world}{\b{Say hello.}}

You shouldn't type the leading dollar sign, which just indicates a generic
terminal prompt. When the commentary is \s{\b{in bold like this}}, it means
that a new command is being introduced.

Often we will give you only a piece of the command and you will have to
complete it yourself. Sample text in \p{bold braces} must be replaced with a
value that you choose or figure out for yourself, such as:

\begin{typeme}
echo \p{the current year} & Say the year (sample as printed) \\
echo \the\year & Say the year (what you actually type)
\end{typeme}

Don't type the braces! With the exception of the leading dollar signs and
these pieces of sample text denoted with braces, \i{always type every command
  exactly as shown in the manual}. Take special care with punctuation and
similar letters --- command-line interfaces are finicky. The characters
\fbox{\t{'}} (single vertical quote), \fbox{\t{`}} (backtick), and
\fbox{\t{"}} (double vertical quote) may look the same but they are all
interpreted differently. Likewise for \fbox{\t{l}} (the letter ell),
\fbox{\t{1}} (the digit one), \fbox{\t{|}} (pipe symbol), and so on.

The exercises are interspersed with questions so that you can check your
understanding. They're represented thusly:

\fillme{0.6in}{What is your name? What is your quest?}

Please actually write down the answers that you and your partner come up with!

There's one more bit of preliminary work to do before we get started in
earnest.


\section{git config}

Before we start using \git\ in earnest, we need to set up some important
configuration. We can do this with the \git\ program itself.

The \git\ program that you run from the terminal is a sort of ``Swiss Army
knife'' tool that provides many \i{commands} that do all sorts of different
things. The command that sets up configuration is (quite sensibly) known as
\cmd{config}. Our first commands will set up some nice features that aren't
turned on by default. Type the following commands in your terminal --- once
again, you should leave out the initial dollar sign:

\begin{typeme}
git config --global color.ui auto & \b{Use colors in printed output.} \\
git config --global core.editor nano & Use \t{nano} to edit files. \\
git config --global alias.ci commit & A useful shorthand. \\
git config --global alias.s status & A useful shorthand.
\end{typeme}

Next we will tell \git\ your name, which it will then embed in all of its logs
of your activity. Remember that below, you should replace the sample text
\p{your name} with your actual name. Remove the braces, but leave the double
quotes.

\typeone{git config --global user.name "\p{your name}"}{Tell \git\ your name.}

You also need to tell \git\ your email address. The value you enter here will
be preserved permanently, so it is best to use a public address that will be
long-lived.

\typeone{git config --global user.email "\p{your email address}"}{Tell git your email.}

Now we can get started for real!


\section{git clone}

We'll get started by setting up a \i{git repository} to play with. This is the
directory containing your actual content (\ie, files) as well as \git's
supporting data.

There are two \git\ commands to set up a repository: \cmd{init}, which creates
a new, empty repository; and \cmd{clone}, which duplicates an existing one.
We'll use the latter so that we have some files to work with right off the
bat.

\begin{typeme}
cd & Move to home directory. \\
mkdir gitlab & Create work directory. \\
cd gitlab & Move into it. \\
git clone https://github.com/pkgw/bloomdemo.git & \b{Clone an existing repository.}
\end{typeme}

Let's see what just happened. The sample text \p{dirname} below should be
replaced with the name of a directory that the \cmd{clone} command creates ---
the first \t{ls} that you run should reveal its name to you.

\begin{typeme}
ls & Examine files. \\
cd \p{dirname} & Enter repository directory. \\
ls & Examine files again. \\
ls -la & Detailed listing of files.
\end{typeme}

By the way, in the final command above, the letter after the dash is an ell,
not a one.

\fillme{0.4in}{Where do \git's supporting data seem to be stored?}

It's worth emphasizing that this cloned repository is both self-contained and
self-sufficient. You can do anything you want to it without having to talk to
\textsf{GitHub} again (without even needing an internet connection, in fact),
and nothing you do will affect the \textsf{GitHub} version unless you
explicitly attempt to synchronize the two. (Which is a vitally important
process for collaborative work, but not something that we're going to worry
about just yet.)

You can see a gory listing of \git's housekeeping files with:

\typeone{find . -print}{\b{Print all file names.}}

\subsection*{Diversion: Getting Help and the Pager}

The \t{find} command above is a Unix program that you may not be familiar
with. There will likely be more of these in the coming pages. If you'd like to
learn more about a program, you can try reading its ``manual page'' with the
\t{man} command:

\typeone{man find}{\b{Learn about \t{find}.}}

When you run \t{man}, you enter a special subprogram called the \i{pager}. The
pager is a tool for navigating lengthy textual output that offers more
features than your terminal. Because \t{man}, \git, and many other Unix tools
use it extensively, it is important to learn a bit about it. Different
programs can do the job of the pager, but by default your system uses a Unix
command called \t{less}. The \t{less} program is mainly controlled by commands
that are single keystrokes. Some of these keys are:

\begin{center}
\label{l.lesskeys}
\begin{tabular}{>{\ttfamily}cl}
\rmfamily\i{Key} & \i{Effect} \\ \hline
q & Quit the pager. \\
\rmfamily(Arrow keys) & Navigate as you'd expect. \\
\rmfamily(Spacebar) & Go forward a page. \\
b & Go backwards a page. \\
< & Go to the top. \\
> & Go to the bottom. \\
/ & Search (type in query, then hit Enter). \\
n & Go to next search result. \\
N & Go to previous search result. \\
\& & Filter (type in query, then hit Enter). \\
h & Print help information.
\end{tabular}
\end{center}

Since we don't want to get too distracted, just press \fbox{\t{q}} to quit the
pager and return to your main terminal prompt.

%(As a double side note, the search and filter commands above use a special
%formalism called \i{regular expressions} or \i{regexes} for matching text. In
%general, you can just type what you're looking for and the right thing will
%happen. \i{Many} Unix tools use regexes; they are just one of the many
%interlocking technologies that constitute the overall Unix ecosystem.)

The \t{man} program has its own manual page:

\typeone{man man}{Learn about \t{man}.}

Unix manual pages are notoriously uneven in their quality. This is especially
true regarding \git\ itself, unfortunately. Google is often a better resource
for beginners. The information on the
\href{http://stackexchange.com/}{StackExchange.com} family of websites is
usually very helpful.

You can run the \t{less} pager program like any other Unix command if you want
to read a file right in your terminal:

\typeone{less README}{\b{Read the bloomdemo repository's \t{README}.}}

\subsection*{Back on Track: Testing your Python}

Let's get back to the \git-ing! Well, almost. We should verify that your
Python setup is working. If you run the following command, you should get a
report about whether certain words are in the dictionary. You should \i{not}
get any big honking error messages. If you do, please call over a lab
assistant.

\typeone{./chkdict barn bern birn born burn}{\b{Check reality of words.}}

This program uses a technique called a \i{Bloom filter} to examine the words
that you specify as arguments (``barn,'' ``bern,'' etc.) and tell you whether
they are found in the English dictionary. Bloom filters are unusual because
they make mistakes in a one-sided way: if a word is in the dictionary, a Bloom
filter will never say that it isn't; but sometimes a Bloom filter will think
that a word is in the dictionary when it really is not. Why would you want
that behavior? Bloom filters are much faster than filters that are always
correct, and sometimes it makes sense to trade accuracy for speed.

Don't worry: the details of Bloom filters aren't important here, and we won't
go into them any further. If you have extra time and are curious, read the
file \t{bloom.py}.


\section{git status, git checkout}

Fundamentally, all \git\ does is track changes to the files in your repository
directory. It does this by comparing the files on disk, the \i{working tree},
with a recent snapshot of their contents. \git\ stores many of these
snapshots, each of which is called a \i{commit}. The most ``recent'' snapshot,
in a sense, is known as the \i{HEAD} commit or just HEAD. Now, in some
circumstances HEAD isn't chronologically the most recent, but for now that's
the best way to think about it.

Let's modify one of the files that \git's tracking in the working tree. We'll
use the \t{nano} command to edit files. Your first task is to edit the file
\t{chkdict} and change the string value that includes the words \t{"MIGHT
  BE"}. For now, just add the words \t{"... or it might not"} to the end of
the string.

\begin{typeme}
nano chkdict & \b{Make a change.} \\
./chkdict barn bern birn born burn & Check that change stuck.
\end{typeme}

The next command we'll learn is \cmd{status}, which tells you about your
\i{local modifications} to the working tree compared to the most recent snapshot:

\typeone{git status}{\b{Check modification status.}}

The \cmd{status} command prints out several pieces of information --- ignore
most of it for now. But you should see \git\ highlight that \t{chkdict} has
been modified. It should also tell you how to discard your changes if you
decide you don't like them. You do this with the \cmd{checkout} command:

\begin{typeme}
git checkout chkdict & \b{Discard changes to chkdict.} \\
./chkdict \p{some words} & Check that change is gone. \\
git status & Check modification status.
\end{typeme}

Your change should be gone, and \git\ should report that your working
directory is \i{clean}. (If it's not, then it is, appropriately, \i{dirty}.)

\fillme{0.4in}{Does \git\ go so far as to restore the modification timestamp
  of \t{chkdict}? You can use \t{ls -l} to check.}

Let's pause for a second here. \i{The ability to discard your changes is in
  fact profoundly important and immensely powerful.} A \i{huge} amount of
progress in programming and scientific research stems from one basic
operation: ``Let's try this and see if it works.'' If you have something that
already works, the chief enemy of progress is the fear of breaking what you do
have. \textit{Git makes it safe to try things.} You can make any insane kind
of change to a file in a \git\ repository, and if you decide you don't like
it, all you need to do is \cmd{checkout}. You will truly have mastered the Zen
of Git when you gleefully shred your most precious files without a care in the
world.

These snapshots also mean that \git\ is a nearly disaster-proof backup tool.
If you have an up-to-date copy of your \t{.git} directory \i{somewhere}, you
can probably recover your files.

\begin{typeme}
rm dictbf.dat.gz & Remove important file. \\
./chkdict barn bern birn born burn & Check that program fails. \\
git status & Check modification status. \\
git checkout dictbf.dat.gz & Restore deleted file. \\
./chkdict barn bern birn born burn & Check that program is healed. \\
pwd & Check your directory. \\
rm -f *.py *.pyc *.gz *dict* README & Type carefully! \\
ls -la & Not quite everything gone. \\
git checkout . & Bring it all back. \\
ls -la & Huzzah!
\end{typeme}

The saved commits in the \t{.git} directory guard against many kinds of
blunders. When you add in \git's ability to synchronize repositories between
different computers, you get almost complete invulnerability to loss of the
data stored in the repository.

Of course, \git\ needs to be tracking any file that you want to protect in
this way. This doesn't happen automatically. The following commands create a
new file called \t{mynewfile} and then delete it. Because we haven't told
\git\ to track \t{mynewfile}, we cannot recover it:

\begin{typeme}
echo hello >mynewfile & Create a new file. \\
git status & Check modification status. \\
rm mynewfile & Remove it. \\
git checkout mynewfile & There's no saving that one.
\end{typeme}


\section{git add, git commit}

Since commits are the way that \git\ remembers your files, we should learn how
to make them! For reasons that we won't go into right now, making commits in
\git\ is a two-step process. First, you have to identify which changes you
want to commit by \i{staging} them with the \cmd{add} command. Then you
actually create the new commit with \cmd{commit}.

To demonstrate this, re-create the modification to \t{chkdict} that you did
before:

\begin{typeme}
nano chkdict & Change the ``MIGHT BE'' line. \\
./chkdict barn bern birn born burn & Validate your change. \\
git status & Check modification status. \\
git add chkdict & \b{Stage the change.} \\
git status & Note change in output. \\
git commit & \b{Commit the staged changes.}
\end{typeme}

When you run \cmd{commit} you will be prompted to write a \i{commit
  message}. There are no rules about the message contents, but every commit
must have one. Generally speaking, more sophisticated and organized projects
will have more detailed policies about what should go in each message. For the
kinds of projects you'll be working on, I suggest a one-line message of this
form:

\hspace{3em}\t{chkdict: change the "MIGHT BE" message for fun}

I find it helpful to identify the section or subsystem that the commit most
strongly affects --- that's the bit before the colon --- and then tersely
summarize what you did.

You \i{also} use \cmd{add} to tell \git\ to start keeping track of a new file.
This is an example of a common annoyance with \git: the same command
(\cmd{add}) will often do very different things, depending on how exactly you
run it.

\begin{typeme}
date >mynewfile & Create a new file. \\
git status & Check modification status. \\
git add mynewfile & \b{Register it.} \\
git status & Note change in output. \\
git commit -m "\p{your message}" & Commit the staged changes.
\end{typeme}

Here we've used a new option to \cmd{commit}: the \t{-m} option, which lets
you write the commit message right on the command line. You'll probably be
mostly writing short messages, so the \t{-m} option can be a big convenience.

\fillme{1.0in}{Say you had done the above steps through \t{git add newfile}
  and then decided you actually didn't want to commit the new file. What
  command would you run to reset things? (Hint: \cmd{git status} is
  informative.) What happens to \t{newfile} in this case?}

There are a couple of other ways to ``stage'' changes to be committed. For
instance, if we decide we don't want to keep \t{mynewfile} around anymore, we
need to use \cmd{rm} to register the removal:

\begin{typeme}
rm mynewfile & Remove our file. \\
git status & Check modification status. \\
git rm mynewfile & \b{Tell \git\ we want to remove it.} \\
git status & Note change in output. \\
git commit -m "\p{deletion message}" & Commit the staged changes.
\end{typeme}

An important point is that \i{\git\ never forgets anything, so even if you
  delete a file from a repository, its contents are still stored and
  recoverable}. This is \underline{very} important if, for example, you
accidentally commit a password into a repository: even if you make a commit to
remove the information, other people can still recover your password. There
are ways to fully delete such information, but we won't get into them here.

There's also a \cmd{mv} command that is the equivalent of an \t{add} and an
\t{rm} together. Both this and \cmd{rm} will perform the specified moves
and/or removals on relevant working-tree files if they haven't already
happened.

Finally, \cmd{commit} has a useful option: the \t{-a} option, which
automatically does the equivalent of \cmd{add} on all of your modified files.
It does \i{not} auto-add untracked files in your working tree. Using the
standard Unix syntax for combining command-line options, we get a very
useful pattern, exemplified here:

\begin{typeme}
date >>README & Modify the README. \\
git commit -am "README: add a timestamp" & Add and commit.
\end{typeme}

Once you develop your finger memory, this is the quickest way to make commits.

\subsection*{Commentary: Commit Sizes and Messages}

Most people starting out with coding and \git'ing tend to evolve towards
writing shorter and shorter messages for larger and larger commits, usually
converging in one large commit made at the end of the day labeled ``Update.''
I \i{strongly, strongly urge} you to try to get into the habit of committing
in small chunks with thought-out log messages, even if it may take a while for
the payoff to become clear.

The fundamental reason is that smaller commits are easier to understand. By
breaking your work into smaller pieces, it's easier to reason about its
correctness and overall design. This is true both as you write new code, and
as you evaluate old code --- every experienced programmer can tell you about
revisiting \i{their own} year-old work and having no idea what they were
thinking when they wrote it.

This path also goes both ways: the effort that you spend reasoning about how
to break down your code into commits will help deepen your understanding of
how to structure software in general. The more you do it, the easier it will
get, and the better programmer you'll be.


\section{git log}

If you do find yourself wanting to review your previous commits, \cmd{log}
is the command to use.

\typeone{git log}{\b{Show the commit history.}}

The \cmd{log} command will open up the same pager program that we saw with the
\t{man} command. But here, \cmd{log} shows you a series of commits, each
associated with an author, a date, and a message. Each commit also has a
\i{commit identifier}, which is the string of 40 random-looking characters.
You should see your own recent commits at the top of the output.

\fillme{0.4in}{On what date was the very first commit made in this repository?
  You may want to consult the table of keystrokes that control \t{less} on
  \autopageref{l.lesskeys}.}

\fillme{0.4in}{Find a commit whose message contains the word ``consuming.'' On
  what date was it made?}

An important aspect of \git\ is that every distinct commit in the universe has
a unique identifier. The identifiers look random but are uniquely determined
by the commit's files and history.

\fillme{1.5in}{(Optional.) Commit identifiers are 40-character hexadecimal
  strings, with each character having 16 possible values (0--9, a--f). If you
  made one new commit every second, about how many Hubble times would need to
  elapse before you used all possible identifiers? The Hubble time is about
  $4.3 \times 10^{17}$~s, and $2^{10} \approx 10^3$.}

The \cmd{log} command can also show you which files were changed in each
commit relative to the one before. This is an \i{enormously} important aspect
of \git\ --- is that it makes it easy not just to view commits, but to
understand the \i{changes} that happened between different commits. The
\cmd{log} command presents change information in a compact form called a
\i{diffstat} that we'll see more of later. It shows how many lines were added
and removed from each file.

\typeone{git log --stat}{\b{Show log, with change statistics.}}

\fillme{0.4in}{In the most recent commit to modify the file \t{INSTRUCTIONS},
  how many lines were added? How many removed?}


\section{git show, git grep, git diff}

While the \cmd{log -{}-stat} command is useful, the most common commands for
examining changes between commits are \cmd{show} and \cmd{diff}. The first of
these will show the set of changes associated with any commit in \i{diff
  format}, which is yet another convention that shows up throughout the Unix
ecosystem. The format should be fairly intuitive to grasp, especially with the
helpful colorful highlighting that \git\ gives you:

\typeone{git show 09933f}{\b{Show the named commit in the pager.}}

Above, we've named a commit based on the beginning of its hexadecimal
identifier. In any given project, five or six hexadecimal digits is almost
always enough to uniquely name a commit. (Optional exercise: how many
different combinations of six hexadecimal digits are there?) You already know
the name of another commit: HEAD.

\typeone{git show HEAD}{Show your most recent commit.}

The diff for this commit will be fairly simple since it was a trivial example
you authored just a little while ago.

\fillme{0.4in}{Use \cmd{log} to find the commit that adds code that uses
  \s{gzip} to compress the Bloom filter data file, then use \cmd{show} to view
  the commit diff. What Python module is needed to add \s{gzip} support?}

Rather than showing an existing commit, the \cmd{diff} command shows the
difference between your working tree and \i{the staged set of changes} ---
\i{not} the most recent commit. We'll demonstrate this with a longer example.
For the sake of pedagogy, please run through the following commands exactly as
presented on your first time through this section.

\subsection*{The Bloom Filter False-Positive Rate}

Read over the \t{chkdict} program. Towards the end you will see that it sets a
variable named \t{fp}, which is the ``false-positive rate'' for the Bloom
filter that it uses. The false-positive rate is the average frequency with
which the Bloom filter will say that a word \i{is} in the dictionary when it
really \i{isn't}. If \t{fp = 0.01}, the filter will think that 1\% of
non-words are actually words, on average. If \t{fp = 0.9}, the filter will
think that 90\% of non-words are actually words. (Once again, there's a
tradeoff: filters with larger false-positive rates are less accurate but more
efficient.)

Modify \t{chkdict} to print out this number before it reports the filter
results for each word. To do this you should just need to add one line of code
to the \t{chkdict} file.

\begin{typeme}
nano chkdict & Edit to print false-positive rate. \\
./chkdict \p{some words} & Check everything works. \\
git diff & \b{Review unstaged changes.} \\
git add chkdict & Stage for committing. \\
git diff & Review unstaged changes.
\end{typeme}

\fillme{0.4in}{What is the reported false-positive rate?}

But wait a minute!

\fillme{0.4in}{Given what you've been told, can the number that your program
  printed possibly be the correct false positive rate?}

\i{Spoiler alert:} No, it cannot.

The false positive rate came from a function called \t{fprate}. You can use
\cmd{grep} to locate its definition: this command searches for a string in the
working tree files. (Technically \cmd{grep} and the search feature of \t{less}
use a Unix formalism called \i{regular expressions} or \i{regexes}, but for
our purposes, you can just type what you're looking for.) If you locate the
function definition and read the surrounding source code, you will see that
the current implementation of the \t{fprate} function is just plain wrong.

\begin{typeme}
git grep fprate & \b{Locate instances of ``fprate''.} \\
nano \p{buggy file} & Fix the bug. \\
./chkdict \p{some words} & Check everything works.
\end{typeme}

\fillme{0.4in}{What is the correct false-positive rate?}

\fillme{0.4in}{(Extra credit.) Use \cmd{checkout} to discard your fix, then
  the new command \cmd{blame} to identify the commit that introduced the bug.
  Which one was it? When done, re-fix the bug. The additional new command
  \cmd{help~blame} may come in handy.}

The next set of commands will work through some of the permutations of having
both staged and unstaged modifications in your working tree --- recall that
above we ran \cmd{add} on our changes to \t{chkdict}, but didn't run
\cmd{commit}.

\begin{typeme}
git status & Check modification status. \\
git diff & Review unstaged changes. \\
git commit & Commit staged changes.
\end{typeme}

\fillme{0.4in}{What change(s) was/were just committed?}

\fillme{0.6in}{If you were to run \cmd{diff} now, after the \cmd{commit}, what
  would you see? (Please try to guess the answer without just running the
  command!)}

\begin{typeme}
git diff & Review unstaged changes. \\
git add \p{remaining file(s)} & Stage for committing. \\
git diff --staged & \b{Review staged changes.} \\
git commit & Commit staged changes. \\
git status & Check modification status.
\end{typeme}

Here, \cmd{diff -{}-staged} is a different mode that examines the differences
between the \i{staged changes} and {HEAD}, while, as we've seen, plain
\cmd{diff} examines the differences between the \i{working tree} and the
\i{staged changes}. If everything has gone well, you'll have a clean working
tree, a new feature in \t{chkdict}, and a fixed bug. You can now muck about
with the working tree however you want, confident that your important fixes
won't be lost.

\begin{typeme}
pwd & Double-check your directory. \\
rm -f *.py *.pyc *.gz *dict* README & Type carefully! \\
ls -l & Confirm file removal. \\
git checkout . & Bring them all back. \\
./chkdict \p{some words} & Verify correct FP rate is produced.
\end{typeme}


\section{git branch, git checkout (redux)}

If you run \git\ without any arguments, you get a listing of its most commonly
used commands:

\typeone{git}{\b{Get help summary.}}

Taking a look at this list, we've touched on almost all of them! The next big
step is to start getting into \git's support for collaborative coding. The
first thing we need to do is understand \i{branches}. And to understand those,
we need to think about commits in a more careful, formal-math kind of way.

In this lab you've made several commits and reviewed them with \cmd{log}. It
would be reasonable to think of commits as coming in a time-ordered series:
you start by making commit~\#1, then commit~\#2, then \#3, and so on, for as
long as you keep on updating your project. For very profound reasons,
\git\ does \i{not} work this way. Instead of being given a unique serial
number, each \git\ commit embeds the unique identifier of the one that it
derives from --- its \i{parent}.

\fillme{2in}{Try to think through the implications of this difference. Think
  graphically, and keep in mind that we're introducing the concept of
  \s{branches}. Any thoughts?}

It is true that in many cases your commits will form a linear chain in time
order. However, they don't \i{have} to. For instance, you can create two
different series of commits that diverge from the same parent --- this is
called \i{forking} or \i{branching}. For now, we won't really deal with
\i{why} you might want to do this: please take my word for it that it'll be
important to understand the underlying process. In fact, \i{the core technical
  breakthrough of \git\ is its ability to deal with branches efficiently.}
This ability is why it's taking over the world against a host of competing
tools. (Also helpful is that it's ridiculously fast and reliable --- if you
``grew up'' with \git, you'll wonder how anyone ever put up with dog-slow,
buggy, piece-of-junk Subversion. Not that I'm bitter.) Not only does
\git\ make it easy to create branches, it provides a tractable mechanism for
\i{merging} them back together --- something we'll discuss in the next
section.

In \git, a ``branch'' is just a name that refers to some specific commit, the
\i{branch head}. That's all you need to reconstruct the entire project history
back to its inception: the named commit embeds the unique identifier of its
parent, which embeds the identifier of \i{its} parent, and so on. You can
store data for many branches at once, but there is only one \i{current
  branch}: the current branch is the one that the working tree and HEAD are
synchronized with. The following command prints out the names of the branches
in your repository:

\typeone{git branch}{\b{List branches.}}

Your repository can track multiple branches, but there can only be one
\i{current branch}, which is denoted in the output of \cmd{branch} with an
asterisk.

\fillme{0.4in}{Our repository has only one branch. What is its name?}

When you run \cmd{commit}, \git\ creates a new commit in its database that
lists the current HEAD as its parent; then the record for the current branch
is updated to point to that new commit. These are both fairly straightforward
operations. For instance, for each branch, the current identity of the branch
head is stored in a simple text file:

\begin{typeme}
cat .git/refs/heads/master & \b{Manually print the master branch commit id.} \\
cat .git/HEAD & Manually print out the branch that HEAD references.
\end{typeme}

(One of the reasons that \git\ is so reliable that commits involve
\i{appending} new information to the repository but almost no \i{rewriting} of
existing information, which is generally more dangerous. This is something to
keep in mind when writing your own data-processing tools.)

It's simple to create new branches. Once you've done so, you can \i{switch
  branches} and alter the current branch with \cmd{checkout} --- another case
of one command doing double duty, like \cmd{add} before. For example, let's
make a new branch that resets your working tree to the pristine files you
originally cloned.

\begin{typeme}
git branch improved \demohead & \b{Make new branch pointing to original files.} \\
git status & Check modification status. \\
\p{clean up any dirtiness in your tree} & Prep for branch switch. \\
git checkout improved & \b{Switch to \t{improved} branch.} \\
git branch & List branches. \\
./chkdict \p{some words} & Verify that FP rate is not printed.
\end{typeme}

\fillme{0.4in}{(Optional.) Use \cmd{log} to verify that \t{\demohead} is the name
  of the commit that you started with when you initially cloned the
  repository.}

Here, \cmd{checkout} has done two things: it's updated information to say that
the current branch is now the one named \s{improved}, not \s{master}, and it's
synchronized your working tree to match \s{improved}. If you had any
uncommitted changes, \cmd{checkout} would have either preserved them or
refused to run if it couldn't.

Let's create a commit on this new branch. Because the active branch is now
\s{improved}, that's the one that will be updated, not \s{master}.

We'll make another silly change. Edit the top of the \t{chkdict} to add a line
that prints your name after all of the \t{import} statements. Below, we've
started assuming that you're getting the hang of things and don't need to see
every \cmd{add} and \cmd{commit} command written out.

\begin{typeme}
nano chkdict & Make the change. \\
\p{review and commit your change} & Commit it. \\
git log --oneline & \b{Summarize history for current branch.} \\
git log --oneline master & Summarize history for master branch. \\
git checkout master & Switch to master. \\
./chkdict \p{some words} & Verify that FP rate is printed. \\
git checkout improved & Switch to improved. \\
./chkdict \p{some words} & Verify that your name is printed.
\end{typeme}

We've also slipped in another argument to \cmd{log}, called \s{-{}-oneline},
that produces a terser form of output.

You should see that the two branches start out with the same history (at the
bottom of the log listings), but then diverge.


\section{git merge}

We've been a bit vague about why you might want to make new branches. The
vagueness will unfortunately continue a while longer as we learn about
\i{merging} branches. The formal-math line of thinking is also going to last a
little bit longer --- but only a little bit.

Above, I wrote that each commit has a parent. That wasn't the whole truth.
Really, each commit has \i{one or more parents}. Correspondingly, the whole
history of a branch isn't just a linear sequence of commits going backwards
from its head --- it's the \i{set} of all parent commits. Topologically,
commits form not just a tree, but a \i{graph}, specifically an awesome
mathematical structure called a \i{directed acyclic graph} or DAG. It's not
worth getting into them here, but they're a very useful reasoning device for
certain problems. DAGs are also the underlying formalism for the legendary
Unix tool \t{make}.

The \cmd{merge} command lets you create \i{merge commits}, which are those
that have more than one parent. Say you have a main branch, \s{master}, and a
side branch, \s{fix-typos}. The branches have \i{diverged} if their histories are
disjoint sets of commits: that is, if \s{master} has commits that are not in
\s{fix-typos}, and \s{fix-typos} has commits that are not in \s{master}. If we
\i{merge fix-typos into master}, that means that we're updating \s{master} to a
merge commit that unifies the two histories. After that point, \s{fix-typos} is
\i{merged into master}, in the sense that the set of commits in its history is
a subset of those in the history of \s{master}.

Yikes. Okay. What does this mean in practice? Let's merge your alternate line
of development into master:

\begin{typeme}
git checkout master & Switch to master. \\
git merge improved & Merge the two. \\
./chkdict \p{some words} & Verify that both your name and FP rate are printed.
\end{typeme}

This sequence of commands will merge the unique changes in your two branches
back together. Namely, your \s{master} branch contains changes that fix the
calculation of the false-positive rate and print it out; your \s{improved}
branched contains changes that print your name when the \t{chkdict} program
runs. The merged code contains both sets of changes.

The \cmd{merge} command will prompt you to write a message for the merge
commit; unless you're working in a sophisticated project, you can usually just
leave it with the default.

Hopefully that seemed straightforward enough. But, what if the \s{master} and
\s{improved} branches had both modified the same part of the same file in
different ways? This is the dreaded \i{merge conflict}.

In practice, \git\ doesn't know how your software actually works, so the only
way to resolve a conflict is through human intervention. If a conflict arises,
\git\ will leave your working tree in a special funky state, with your files
modified to indicate where the conflicts are. You must decide how to resolve
the conflicts, then mark them as dealt with using \cmd{add}, and then finally
\cmd{commit} when everything is fixed. Things are a little bit simpler than
you might fear since the various commands will tell you the necessary steps as
you go through them. We'll work through a merge using some secret branches
that came along with our clone:

\begin{typeme}
git branch newstuff origin/master & New branch with pristine files. \\
git checkout newstuff & Switch to \t{newstuff} branch. \\
git show origin/goodbye-option & See changes in \t{goodbye-option} branch. \\
git show origin/no-skipmisses-option & Likewise. \\
git merge origin/no-skipmisses-option & Merge in \t{no-skipmisses-option}. \\
git merge origin/goodbye-option & Likewise.
\end{typeme}

At this point, \git\ should report a conflict. \git\ will edit the conflicted
files to show the overlapping changes. Specifically, it will show a long row
of ``\t{<<<<}'', the contents from one branch, then ``\t{====}'', the contents
from the other branch, and finally ``\t{>>>>}''. It's up to you to find all
instances of these conflicts and edit the files to somehow do what \i{both}
commits were attempting. In the example above, the requisite merge isn't too
complicated. By reviewing the histories of the relevant branches, you should
be able to see what each commit was trying to accomplish, and find a way to
accomplish both goals in the merged \t{chkdict}.

\begin{typeme}
git status & Report merge/conflict state. \\
\p{edit affected file} & Fix the conflict. \\
git add \p{affected file} & Stage the fix. \\
git commit & Commit the fix. \\
git log & Review commit history.
\end{typeme}

\fillme{1.5in}{What does the commit history of the \t{newstuff} branch look
  like, as a graph?}

\subsection*{Commentary: Well-definedness of merges}

Some merges are not semantically possible. If one branch of a command-line
program adds an option called \t{-s} to sort output, and another adds an
option called \t{-s} to save inputs, there's just no way to merge the two
branches while preserving their intent. When you make a merge commit, you're
\i{asserting} to \git\ that it preserves the meanings of the two merged
branches in some reasonable way, but it's impossible for \git, or any other
objective analysis, to \i{prove} that this is the case. In fact, you could
``resolve'' a merge conflict by replacing all the contents of every file in
your project with the Doctor Who fan fiction.

What underlies the way that \git's merge system works is an assumption that
\i{modifications to different parts of different files are probably
  independent} --- it will only flag a conflict if two commits modify the
\i{same} part of the \i{same} file. But it's easy to construct cases where
this assumption fails. For instance, I could merge two branches where one
renames a variable in file \t{A}, while the other references the old variable
name in file \t{B}. There's no way to detect the problem without running the
code. More broadly speaking, \i{a merge is not a well-defined, mechanical
  operation, and it can never be entirely automated}. Fortunately, in the real
world, the different-places-means-independence assumption is generally true,
and most merges can proceed mechanically.

Stepping back, the same general point is true of any kind of commit. Commits
in a sequence are generally assumed to be related and not include enormous
changes. But there's no reason that I can't make a single commit that deletes
all of the source code to my project and replaces it with Doctor Who fan
fiction. Fundamentally, every \git\ commit both encodes something very precise
and something very nebulous. The precise thing is an exact, reproducible
snapshot of a set of files in a repository. The nebulous thing is an assertion
by a human that those files bear some useful relation to the ones found in the
commits that came before.


\section{git remote, git fetch, git pull}

Finally we get to the payoff. \i{The features of \git's branching system are
  sufficient to allow collaborative work on a project by a distributed,
  decentralized team.} Or, more prosaically, \git's ability to synchronize
repositories between computers builds on its branching and merging
infrastructure. So even if you're not planning on contributing to the Linux
kernel any time soon, a solid understanding of the branching system is
important for synchronizing your work between different machines and sharing
your work with others.

Each \git\ repository stores a list of other repositories that it knows about,
known as \i{remotes}. These can be in a different directory on the same
machine, or accessible over the network using any of several protocols. You
can download updates from a remote and, as we'll see in the next section, also
\i{push} updates to it. The simplest way to collaborate using \git\ is to set
up a central repository on the network that everyone can push to --- which is
exactly what \href{https://github.com/}{GitHub} does and why it's so popular.
Other, less-centralized models are possible, but we won't discuss them here.
It bear emphasizing, however, that a key advantage of \git\ is that if
\href{https://github.com/}{GitHub} were to disappear tomorrow, we wouldn't
lose any data, because each repository is self-sufficient, and by setting up
new remotes we could start collaborating again almost seamlessly.

Every cloned repository starts with a remote called \s{origin}, which you've
probably been seeing mentioned by various tools over the course of the lab.
You can learn about your remotes with, unsurprisingly, the \cmd{remote}
command.

\begin{typeme}
git remote & List named remotes. \\
git remote show origin & Show details about \t{origin}.
\end{typeme}

Each remote is associated with \i{remote branches}, which the \cmd{remote
  show} command just listed for us. The \cmd{branch} command will also list
them if you give it the \t{-a} (``all branches'') option:

\typeone{git branch -a}{Show all branches.}

You can't make commits on these branches yourself. However, you can download
updates from the remote with the \cmd{fetch} command. We can run it here, but
since I haven't craftily updated \s{origin} since this lab started, all you'll
see is silence, indicating that there are no new commits:

\typeone{git fetch origin}{Update remote branches for origin.}

If there \i{were} new commits, what would you do? Well, you've got a branch
that you're working on (generally \s{master}, or \s{newstuff} here), and
you've got one with commits that you want to import (\s{origin/master} ---
note that the \s{remotes/} prefix isn't necessary). That sounds like time for
a \cmd{merge}!

\begin{typeme}
git checkout newstuff & Make sure we're on the right branch. \\
git merge origin/master & Merge in (nonexistent) updates.
\end{typeme}

The command \cmd{pull} essentially does a \cmd{fetch} followed by a
\cmd{merge}, though it has a few bells and whistles. Generally speaking,
\cmd{pull} should be your go-to pull-in-new-changes command.

\typeone{git pull origin master}{Fetch and merge nonexistent updates, again.}


\section{git push}

Finally, there's the matter of \i{pushing} updates to a remote repository. In
practice you'll generally be doing this by pushing updates to
\href{https://github.com/}{GitHub}, but to keep the lab self-contained we're
going to do everything on your local disk. \git\ does a good job of
abstracting between different kinds of remotes, so the underlying steps are
exactly the same in either case.

\begin{typeme}
mkdir ../sync.git & Create sync repo directory. \\
cd ../sync.git & Move into it. \\
git init --bare & Create push-able repo. \\
ls & Examine files. \\
cd ../bloomdemo & Back to working tree. \\
git remote add localsync ../sync.git & Register the new repo. \\
git push localsync improved & Publish our \t{improved} branch. \\
git remote show localsync & Show details about \t{localsync}.
\end{typeme}

This sequence of commands creates a local repository that we can push to. The
\t{sync.git} directory is a \i{bare repository}: it has commit data, branches,
and a HEAD, but no actual working tree! You can't push to a repository with a
working tree since \git\ would need to be able to rewrite all the working
files, which it can't safely do if there happen to be local modifications. The
files in the \t{sync.git} directory are the same as those in your working
tree's \t{.git} directory. It's conventional to give bare repositories names
ending with \t{.git} even though they're directories.

The \cmd{push} command has somewhat-sophisticated syntax allowing you to remap
branch names between repositories. For instance, to publish our \t{master}
branch under the name \t{experiments} on \t{localsync}, you write:

\begin{typeme}
git branch -a & List all branches. \\
git push localsync master:experiments & Publish \t{master} as \t{experiments}. \\
git branch -a & List all branches. \\
git remote show localsync & Show details about \t{localsync}. \\
git push localsync :experiments & Delete \t{experiments} on \t{localsync}. \\
git remote show localsync & Show details about \t{localsync}.
\end{typeme}

\fillme{0.4in}{What's different the second time you run \cmd{branch~-a}?}

As we see above, the special syntax of pushing a blank branch name (``\t{git
  push localsync :experiments}'') deletes the branch on the remote. Having
successfully pushed our changes, we can now shred our files without worrying.

\begin{typeme}
cd .. & Move to \t{gitlab} directory. \\
rm -rf bloomdemo & Destroy our work. \\
ls -la & Confirm it's gone. \\
git clone https://github.com/pkgw/bloomdemo.git & Clone an existing repository. \\
cd bloomdemo & Move into it. \\
git remote add localsync ../sync.git & Register our backup. \\
git branch -a & List all branches. \\
git fetch localsync & Fetch data from localsync. \\
git branch -a & List all branches. \\
git merge localsync/improved & Merge in our work. \\
./chkdict \p{some words} & Confirm our bugfix.
\end{typeme}


\section*{Recap}

That's the end of the lab! What should you take away from this all?

\begin{itemize}
\item From one angle, \git\ is an excellent \i{backup tool} for your files.
\item From another, it's a \i{freedom tool} that lets you experiment in your
  projects, secure in the knowledge that you can reset things to a known-good
  state if you decide that you messed up.
\item It's also an amazing \i{collaboration tool} that provides a tractable
  way for groups of people to work together on projects in a decentralized
  manner.
\item It is also, admittedly, a \i{complicated tool} with many esoteric
  features and a sophisticated underlying theoretical model. We've barely
  scratched the surface of its capabilities.
\end{itemize}

If you don't want to be chained to a paper copy of this lab manual, is there
an electronic form? There is, and it's tracked in \git, of course:

\bigskip
{\large\centering\url{https://github.com/pkgw/git-lab}\par}


\section*{git Command Quick Reference}

There are many commands that are not listed, and all of these commands can do
much more than is given in the summaries below.

\begin{center}
\begin{tabular}{>{\ttfamily}ll}
\rmfamily\i{Command} & \i{Purpose} \\ \hline
git add \p{files} & Stage files for committing, or register new files. \\
git branch \p{name} \p{initial} & Create a new branch pointing at \s{initial}. \\
git checkout \p{branch} & Switch to a new branch. \\
git checkout \p{file} & Restore a file to its HEAD state. \\
git clone \p{URL or path} & Clone an existing repository. \\
git commit & Make a new commit. \\
git diff & Show changes between working tree and staged changes. \\
git diff --staged & Show changes between staged changes and HEAD. \\
git fetch & Fetch updates from a remote. \\
git grep \p{regex} & Search for text in the repository contents. \\
git init & Create a new empty repository. \\
git log & Show commit logs. \\
git merge \p{branch} & Merge another branch into the current one. \\
git mv \p{old} \p{new} & Rename a file. \\
git pull & Combination of \t{fetch} and \t{merge}. \\
git push & Publish updates to a remote. \\
git rm \p{file} & Delete a file. \\
git show \p{commit} & Show the changes in a commit. \\
git status & Report status of the working tree.
\end{tabular}
\end{center}

\end{document}
