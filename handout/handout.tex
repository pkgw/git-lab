\documentclass[letterpaper,12pt,titlepage,twoside]{article}
\input setup

\title{A Laboratory Introduction to \git}
\author{P. K. G. Williams (\href{mailto:peter@newton.cx}{peter@newton.cx})}
\date{\today}

\begin{document}
\maketitle

\section*{Introduction\markboth{Introduction}{}}

Welcome to the \git\ lab! This manual aims to help you learn the fundamentals
of this awesome tool by walking you through some exercises that demonstrate
its everyday functionality. Along the way we'll discuss some of its underlying
principles and demonstrate some basic Unix shell skills too. We should note
that we're assuming that you've already been given a broad overview of what
\git\ is, and why you might want to use it.

Learning \git\ is like learning an instrument, or a language. There are
certain concepts to master, but there's also just a lot of practice involved:
repeating certain motions so that they become automatic. When it comes to
computers, Unix pros talk about \i{finger memory}: I can type out \t{git
  commit -am} in my sleep. Of course, there's also the deeper appreciation of
the underlying concepts and esoteric possibilities that you gain as you use a
tool more and more. My assertion to you is that \i{time spent practicing
  \git\ will more than repay itself in the future}. If you're just starting
out as a programmer (\ie, you've written less than 100,000 lines of code or
so), some of its advantages are a bit hard to grasp; for what it's worth, the
developer site \href{https://github.com/}{GitHub} has more than 4.5 million
users and 6 million \git\ repositories.

\i{This lab is best done with a partner.} Real-deal education research shows
that it's much faster for you to learn something when talking it over with a
partner rather than just staring at it by yourself. Getting back to the finger
memory thing, though, please try to switch off between who's ``driving'' the
keyboard and who's watching and commenting. It really does make a difference!

If you and your partner get stuck on something, trying asking the group next
to you, or Google. Your lab assistants are happy to help you out, of course,
but you'll learn more if you spend some time trying to solve problems on your
own. That being said, with computers sometimes things go wrong even if you've
done everything right --- if you see a truly strange error message,
particularly one associated with a non-\git\ command, it's probably better to
summon the lab assistants sooner rather than later. Deeper conceptual
questions (``why'' rather than ``how'') are also good to bring to the
assistants.


\subsection*{Notation in this manual}

Important terminology will be introduced in \i{italics}. Computer-y words will
be written in a monospace font \t{like this}. Commands that you should type in
are presented with commentary this way, sometimes with parameters that you
need to figure out for yourself:

\begin{typeme}
echo hello world & Say hello. \\
echo \p{your name} & Say your name.
\end{typeme}

You shouldn't type the leading dollar sign, which is just meant to indicate a
generic terminal prompt, or the braces. The exercises are interspersed with
questions so that you can check your understanding. They're represented
thusly:

\fillme{0.4in}{What is your name? What is your quest?}

There's one more bit of preliminary work to do before we get started in
earnest.


\section{.gitconfig}

Before we proceed, each participant in the lab should set up a file named
\t{.gitconfig} in her or his home directory to set up a few important
parameters:

\begin{typeme}
cd & Move to your home directory. \\
\p{edit the file .gitconfig} & Set up \t{.gitconfig}.
\end{typeme}

The file should look like this:

\begin{adjustwidth}{2.5em}{0pt}
\ttfamily
[user]\\
name = \p{your name}\\
email = \p{your email}\\
\\{}
[color]\\
ui = auto\\
\\{}
[alias]\\
ci = commit\\
s = status
\end{adjustwidth}

Now we can get started for real!


\section{git clone}

We'll get started by setting up a \i{git repository} to play with. This is the
directory containing your actual content (\ie, files) as well as \git's
supporting data. The \git\ tool is made of many \i{commands}, which are
invoked as shown below. There are two commands to set up a repository:
\cmd{init}, which creates a new, empty repository; and \cmd{clone}, which
duplicates an existing one. We'll use the latter so that we have some files to
work with right off the bat.

\begin{typeme}
cd & Go to home directory. \\
mkdir gitlab & Create work directory. \\
cd gitlab & Move into it. \\
git clone https://github.com/pkgw/bloomdemo.git & Clone an existing repository.
\end{typeme}

Let's see what just happened:

\begin{typeme}
ls & Examine files. \\
cd \p{dirname} & Enter repository directory. \\
ls & Examine files again. \\
ls -la & Detailed listing of files.
\end{typeme}

By the way, in the final command above, the letter after the dash is an ell,
not a one.

\fillme{0.4in}{Where do \git's supporting data seem to be stored?}

It's worth emphasizing that this cloned repository is both self-contained and
self-sufficient. You can do anything you want to it without having to talk to
\textsf{GitHub} again (without even needing an internet connection, in fact),
and nothing you do will affect the \textsf{GitHub} version unless you
explicitly attempt to synchronize the two. (Which is a vitally important
process for collaborative work, but not something that we're going to worry
about for a little while.)

You can see a gory listing of \git's housekeeping files with:

\typeone{find . -print}{Print all file names.}

Here, \t{find} is a Unix command that you may not be familiar with; there will
likely be more in the coming pages. If you'd like to learn more about a
command, you can try reading its manual page:

\begin{typeme}
man find & Learn about \t{find}. \\
man man & Learn about \t{man}.
\end{typeme}

\ldots\ although Unix manual pages are notoriously uneven in their quality.
(This is especially true regarding \git\ itself, unfortunately.) Google is
often a better resource for beginners. The information on the
\href{http://stackexchange.com/}{StackExchange.com} family of websites is
usually very helpful.

Finally, let's verify that your Python setup is functional. If you run the
following command, you should get a report about whether certain words are in
the dictionary. You should \i{not} get any big honking error messages.

\typeone{./indict barn bern birn born burn}{Check reality of words.}

For now, we're going to ignore how this program works. If you have extra time
and are curious, read the file \t{bloom.py}. (The program name is as in ``in
dictionary?'', not criminal charges.)


\section{git status, git checkout}

Fundamentally, all \git\ does is track changes to the files in your repository
directory. It does this by comparing the files on disk, the \i{working tree},
with a recent snapshot of their contents. \git\ stores many of these
snapshots, each of which is called a \i{commit}. The most ``recent'' snapshot,
in a sense, is known as the \i{HEAD} commit or just HEAD. Now, in some
circumstances HEAD isn't chronologically the most recent, but for now that's
the best way to think about it. Anyway, let's modify one of the files that
\git's tracking in the working tree:

\begin{typeme}
\p{edit `indict' and modify the ``MIGHT BE'' message} & Make a change. \\
./indict barn bern birn born burn & Check that change stuck. \\
git status & Check modification status.
\end{typeme}

The \cmd{status} command will print out several pieces of information ---
ignore most of it for now. You should see \git\ highlight that \t{indict} has
been modified. It should also tell you how to discard your changes if you
decide you don't like them:

\begin{typeme}
git checkout indict & Discard changes to indict. \\
./indict \p{some words} & Check that change is gone. \\
git status & Check modification status.
\end{typeme}

Your change should be gone, and \git\ should report that your working
directory is \i{clean}. (If it's not, then it is, appropriately, \i{dirty}.)

\fillme{0.4in}{Does \git\ go so far as to restore the modification timestamp
  of \t{indict}? You can use \t{ls -l} to check.}

Let's pause for a second here. \i{The ability to discard your changes is in
  fact profoundly important and immensely powerful.} A \i{huge} amount of
progress in programming and scientific research stems from one basic
operation: ``Let's try this and see if it works.'' If you have something that
already works, the chief enemy of progress is the fear of breaking what you do
have. \textit{Git makes it safe to try things.} You can make any insane kind
of change to a file in a \git\ repository, and if you decide you don't like
it, all you need to do is \cmd{checkout}. You will truly have mastered the Zen
of Git when you gleefully shred your most precious files without a care in the
world.

These snapshots also mean that \git\ is a nearly disaster-proof backup tool.
If you're not used to it, the ``\t{rm~-rf~*}'' below means ``delete everything
here recursively'' -- only run it when you're very sure that you're in the
right directory and that you mean it.

\begin{typeme}
rm dictbf.dat.gz & Blow away important file. \\
./indict barn bern birn born burn & Check that program fails. \\
git status & Check modification status. \\
git checkout dictbf.dat.gz & Restore deleted file. \\
./indict barn bern birn born burn & Check that program is healed. \\
pwd & Check your directory. \\
rm -rf * & Type carefully! \\
ls -la & Well, not quite everything. \\
git checkout . & Bring it all back. \\
ls -la & Huzzah!
\end{typeme}

The saved commits in the \t{.git} directory guard against many kinds of
blunders. When you add in \git's ability to synchronize repositories between
different computers, you get almost complete invulnerability to loss of the
data stored in the repository.

Of course, \git\ needs to be tracking any file that you want to protect in
this way. This doesn't happen automatically:

\begin{typeme}
echo hello >mynewfile & Create a new file. \\
git status & Check modification status. \\
rm mynewfile & Blow it away. \\
git checkout mynewfile & There's no saving that one.
\end{typeme}


\section{git add, git commit}

It looks like we ought to learn how to make commits. As you might guess,
broadly speaking you have to tell \git\ to make a new commit based on the
files you have in your working directory. This is actually a two-step process,
however, for reasons that we won't go into right now. First, you have to
identify which changes you want to commit by \i{staging} them with the
\cmd{add}. Then you actually create the new commit with \cmd{commit}.

\begin{typeme}
\p{edit `indict' and modify the ``MIGHT BE'' message} & Make a change. \\
./indict barn bern birn born burn & ``Test'' your change. \\
git status & Check modification status. \\
git add indict & Stage the change. \\
git status & Note change in output. \\
git commit & Commit the staged changes.
\end{typeme}

When you run \cmd{commit} you will be prompted to write a \i{commit
  message}. There are no rules about the message contents, but every commit
must have one. Generally speaking, more sophisticated and organized projects
will have more detailed policies about what should go in each message. For the
kinds of projects you'll be working on, I suggest a one-line message of this
form:

\hspace{3em}\t{Chapter 2: Update the section on calibration}

I've found it helpful to identify the section or subsystem that the commit
most strongly affects (that's the bit before the colon), as well as a terse
summary of what you did.

You also use \cmd{add} to tell \git\ to start keeping track of a new file.

\begin{typeme}
date >mynewfile & Create a new file. \\
git status & Check modification status. \\
git add mynewfile & Register it. \\
git status & Note change in output. \\
git commit -m "\p{your message}" & Commit the staged changes.
\end{typeme}

Here we've used the \t{-m} option to \cmd{commit}, which lets you write the
commit message right on the command line. You'll probably be mostly writing
short messages, so the \t{-m} option can be a big convenience.

\fillme{1.0in}{Say you had done the above steps through \t{git add newfile}
  and then decided you actually didn't want to commit the new file. What
  command would you run to reset things? What happens to \t{newfile} in this
  case?}

There are a couple of other ways to stage changes to be committed. For
instance, if we decide we don't want to keep \t{mynewfile} around anymore, we
need to use \cmd{rm} to register the deletion:

\begin{typeme}
rm mynewfile & Delete our file. \\
git status & Check modification status. \\
git rm mynewfile & Tell \git\ we want to delete it. \\
git status & Note change in output. \\
git commit -m "\p{deletion message}" & Commit the staged changes.
\end{typeme}

An important point is that \i{\git\ never forgets anything, so even if you
  delete a file from a repository, its contents are still stored and
  recoverable}. This is important if you, say, accidentally commit a password
into a repository: even if you make a commit to remove the information, anyone
with a clue can still get it back. There are ways to fully delete such
information, but we won't get into them here.

There's also a \cmd{mv} command that is the equivalent of an \t{add} and an
\t{rm} together. Both this and \cmd{rm} will perform the specified moves
and/or deletions on relevant working-tree files if they haven't already
happened.

Finally, \cmd{commit} has an important \t{-a} option to automatically do the
equivalent of \cmd{add} on all of your modified files. It does \i{not}
auto-add untracked files in your working tree. Using the standard Unix syntax
for combining command-line options, we get a very important pattern,
exemplified here:

\begin{typeme}
date >>README & Modify the README. \\
git commit -am "README: add a timestamp" & Add and commit.
\end{typeme}

I truly recommend just making sure to run this command at least a few times
each day until you don't even have to think about typing it.

\subsection*{Commentary: Commit Sizes and Messages}

Most people starting out with coding and \git'ing tend to evolve towards
writing shorter and shorter messages for larger and larger commits, usually
converging in one large commit made at the end of the day labeled ``Update.''
I \i{strongly, strongly urge} you to try to get into the habit of committing
in small chunks with thought-out log messages, even if it may take a while for
the payoff to become clear.

The fundamental reason is that smaller commits are easier to understand. By
breaking your work into smaller pieces, it's easier to reason about its
correctness and overall design. This is true both as you write new code, and
as you evaluate old code --- every experienced programmer can tell you about
revisiting \i{their own} year-old work and having no idea what they were
thinking when they wrote it.

This path also goes both ways: the effort that you spend reasoning about how
to break down your code into commits will help deepen your understanding of
how to structure software in general. The more you do it, the easier it will
get, and the better programmer you'll be. One a more mundane level, as I've
emphasized, this is also true of the mechanical act of typing
\cmd{ci~-am~"\ldots"} and composing a decent commit message.


\section{git log}

If you do find yourself wanting to review your previous commits, \cmd{log}
is the command to use.

\typeone{git log}{Show log of changes.}

When you run \cmd{log}, you enter a special subprogram called the \i{pager}.
The pager is a tool for navigating lengthy textual output that offers more
features than your terminal, and \git\ (along with many other Unix tools) uses
it extensively. Under default settings, your pager is a Unix command called
\t{less}, which is mainly controlled by commands that are single keystrokes.
Among them are:

\begin{center}
\begin{tabular}{>{\ttfamily}cl}
\rmfamily\i{Key} & \i{Effect} \\ \hline
q & Quit. \\
\rmfamily(Arrow keys) & Navigate as you'd expect. \\
< & Go to the top. \\
> & Go to the bottom. \\
/ & Search (type in query, then hit Enter). \\
n & Go to next search result. \\
N & Go to previous search result. \\
\& & Filter (type in query, then hit Enter). \\
? & Print help information.
\end{tabular}
\end{center}

As a side note, the search command above uses a special formalism called
\i{regular expressions} or \i{regexes} for matching text. In general, you can
just type what you're looking for and the right thing will happen. You will
find that \i{many} Unix tools use regexes; they are just one of the many
interlocking technologies that constitute the overall Unix ecosystem.

You'll see that the output of \cmd{log} is a series of commits, each
associated with an author, date, and message. Each commit also has a \i{commit
  identifier}, which is the string of 40 random-looking characters. You should
see your own recent commits at the top of the output.

\fillme{0.4in}{On what date was the very first commit made in this
  repository?}

\fillme{0.4in}{Find a commit whose message contains the word ``consuming.'' On
  what date was it made?}

An important aspect of \git\ is that every distinct commit in the universe has
a unique identifier.

\fillme{1.5in}{(Optional.) Commit identifiers are 40-character hexadecimal
  strings, with each character having 16 possible values (0--9, a--f). If you
  made one new commit every second, about how many Hubble times would need to
  elapse before you used all possible identifiers? The Hubble time is about
  $4.3 \times 10^{17}$~s, and $2^{10} \approx 10^3$.}

The \cmd{log} command can also show you which files were changed in each
commit. It presents this information in a compact form called a \i{diffstat}
that we'll see more of later. It shows how many lines were added and removed
from each file.

\typeone{git log --stat}{Show log, with change statistics.}

\fillme{0.4in}{In the most recent commit to modify the file \t{INSTRUCTIONS},
  how many lines were added? How many removed?}


\section{git show, git grep, git diff}

To take a closer look at changes, you can use \cmd{show} and \cmd{diff}.
The first of these will show the set of changes associated with any commit in
\i{diff format}, which is yet another convention that shows up throughout the
Unix ecosystem. The format should be fairly intuitive to grasp, especially
with the helpful colorful highlighting that \git\ gives you:

\begin{typeme}
git show c16a09 & Show the named commit in the pager.
\end{typeme}

Above, we've named a commit based on the beginning of its hexadecimal
identifier. In any given project, five or six hexadecimal digits is almost
always enough to uniquely name a commit. You already know the name of another
commit: HEAD.

\begin{typeme}
git show HEAD & Show your most recent commit.
\end{typeme}

The diff for this commit will be fairly simple since it was a trivial example
you authored just a little while ago.

\fillme{0.4in}{Use \cmd{log} to find the commit that adds support for
  \s{gzip} compression of the data file and \cmd{show} to view the commit
  diff. What Python module is needed to add \s{gzip} support?}

Rather than showing an existing commit, the \cmd{diff} command shows the
difference between your working tree and \i{the staged set of changes} ---
\i{not} the most recent commit. We'll demonstrate this with a longer example.
(For the sake of pedagogy, please run through the following commands exactly
as presented your first time through this section.)

If you examine the \t{indict} program, you see that it computes a
false-positive rate for the technique it's using, which is called a ``Bloom
filter.'' Let's modify \t{indict} to print out this number before it reports
the filter results for each word.

\begin{typeme}
\p{edit `indict' and make it print out \t{fp}} & Print false-positive rate. \\
./indict \p{some words} & Check everything works. \\
git diff & Review unstaged changes. \\
git add indict & Stage for committing. \\
git diff & Review unstaged changes.
\end{typeme}

\fillme{0.4in}{What is the reported false-positive rate?}

But wait a minute!

\fillme{0.4in}{Does that number make any sense?}

The false positive rate came from a function called \t{fprate}. You can use
\cmd{grep} to locate its definition: it searches for a string in the working
tree files using --- just as we saw above with the pager's search feature ---
a regex. If you locate the function definition, the origin of the buggy output
is clear.

\begin{typeme}
git grep fprate & Locate instances of ``fprate''. \\
\p{edit buggy file} & Fix the bug. \\
./indict \p{some words} & Check everything works.
\end{typeme}

\fillme{0.4in}{What is the correct false-positive rate?}

\fillme{0.4in}{(Extra credit.) Use \cmd{checkout} to discard your fix, then
  the new command \cmd{blame} to identify the commit that introduced the bug.
  Which one was it? When done, re-fix the bug. \cmd{help~blame} may be
  \ldots\ helpful.}

The next set of commands will work through some of the permutations of having
both staged and unstaged modifications in your working tree --- recall that
above we ran \cmd{add} on our changes to \t{indict}, but didn't run
\cmd{commit}.

\begin{typeme}
git status & Check modification status. \\
git diff & Review unstaged changes. \\
git commit & Commit staged changes.
\end{typeme}

\fillme{0.4in}{What change(s) was/were just committed?}

\fillme{0.6in}{If you were to run \cmd{diff} now, after the \cmd{commit},
  what would you see? (Err, please try to guess the answer without just
  running the command.)}

\begin{typeme}
git diff & Review unstaged changes. \\
git add \p{remaining file(s)} & Stage for committing. \\
git commit & Commit staged changes. \\
git status & Check modification status.
\end{typeme}

If everything has gone well, you'll have a clean working tree, a new feature
in \t{indict}, and a fixed bug. You can now muck about with the working tree
however you want, confident that your important fixes won't be lost.

\begin{typeme}
pwd & Double-check your directory. \\
rm -rf * & Type carefully! \\
git checkout . & Bring it all back. \\
./indict \p{some words} & Verify correct FP rate is produced.
\end{typeme}


\section{git branch, git checkout (redux)}

If you run \git\ without any arguments, you get a listing of its most commonly
used commands:

\typeone{git}{Get help summary.}

Taking a look at this list, we've touched on almost all of them! The next big
step is to start getting into \git's support for collaborative coding. The
first thing we need to do is understand \i{branches}. And to understand those,
we need to think about commits in a more careful, formal-math kind of way.

In this lab you've made several commits and reviewed them with \cmd{log}. It
would be reasonable to think of commits as coming in a time-ordered series:
you start by making commit~\#1, then commit~\#2, then \#3, and so on, for as
long as you keep on updating your project. For very profound reasons,
\git\ does \i{not} work this way. Instead, each \git\ commit merely records
the unique identifier of the one that came before it --- its \i{parent}.

\fillme{2in}{Try to think through the implications of this difference. Think
  graphically, and keep in mind that we're introducing the concept of
  \s{branches}. Any thoughts?}

It is true that in many cases your commits will form a linear chain in time
order. However, they don't \i{have} to. You can \i{fork} --- create a new
\i{branch} --- and have two series of commits diverging from the same parent.
For now, we won't really deal with \i{why} you might want to do this: please
take my word for it that it'll be important to understand the underlying
process. In fact, \i{the core technical breakthrough of \git\ is its ability
  to deal with forks in an efficient, sane way.} This ability is why it's
taking over the world against a host of competing tools. (Also helpful is that
it's ridiculously fast and reliable --- if you ``grew up'' with \git, you'll
wonder how anyone ever put up with dog-slow, buggy, piece-of-junk Subversion.
Not that I'm bitter.) A key aspect of this support is that is that \git\ makes
it feasible to \i{merge} forks tractably, which we'll discuss in the next
section.

In \git, a branch is just a name referring to a commit, the \i{branch head}.
That's all you need to reconstruct the entire project history back to its
inception: the named commit points to its parent, which points to its parent,
and so on. You can store data for many branches at once, but there is only one
\i{current branch}: the current branch is the one that the working tree and
HEAD are synchronized with. The following command prints out the names of the
branches in your repository:

\typeone{git branch}{List branches.}

\fillme{0.4in}{We only have one branch, the default one. What is its name?}

When you run \cmd{commit}, a new commit is recorded, and the information for
the current branch is updated to point to that new commit. That's all you need
to do to move the branch forward, and by induction that's still all we need to
reconstruct the entire history. It's literally that simple, with the branch's
commit pointer being stored in a simple text file:

\begin{typeme}
cat .git/refs/heads/master & Manually print the master branch commit id. \\
cat .git/HEAD & Manually print out the branch that HEAD references.
\end{typeme}

(One of the reasons that \git\ is so reliable that commits involve
\i{appending} new information to the repository but almost no \i{rewriting} of
existing information, which is generally more dangerous. This is something to
keep in mind when writing your own data-processing tools.)

It's simple to create new branches. Once you've done so, you can \i{switch
  branches} with \cmd{checkout} --- which is a sort of understandable double
duty, if you think of \cmd{checkout}'s job as being to synchronize your
working tree files with information in the repository. We'll make a new branch
that resets your working tree to the pristine files you originally cloned.

\begin{typeme}
git branch take2 82c765 & Make new branch pointing to original files. \\
git status & Check modification status. \\
\p{Clean up any dirtiness in your tree} & Prep for branch switch. \\
git checkout take2 & Switch to \t{take2} branch. \\
git branch & List branches. \\
./indict \p{some words} & Verify that FP rate is not printed.
\end{typeme}

\fillme{0.4in}{(Optional.) Use \cmd{log} to verify that \t{82c765} is the name
  of the commit that you started with when you initially cloned the
  repository.}

Here, \cmd{checkout} has done two things: it's updated information to say that
the current branch is now \s{take2}, not \s{master}, and it's synchronized
your working tree to match \s{take2}. If you had any uncommitted changes,
\cmd{checkout} would have either preserved them or refused to run if it
couldn't.

Let's create a commit on this new branch. Because the active branch is now
\s{take2}, that's the one that will be updated, not \s{master}.

\begin{typeme}
\p{Edit the top of \t{indict} to print your name.} & Make a change. \\
\p{Review and commit your change.} & Commit it. \\
git log --oneline & Summarize history for current branch. \\
git log --oneline master & Summarize history for master branch. \\
git checkout master & Switch to master. \\
./indict \p{some words} & Verify that FP rate is printed. \\
git checkout take2 & Switch to take2. \\
./indict \p{some words} & Verify that your name is printed.
\end{typeme}

You should see that the two branches start out with the same history (at the
bottom of the log listing), but then diverge.


\section{git merge}

We've been a bit vague about why you might want to make new branches. The
vagueness will unfortunately continue a while longer as we learn about
\i{merging} branches. The formal-math line of thinking is also going to last a
little bit longer --- but only a little bit.

Above, I said that each commit has a parent. That wasn't the whole truth.
Really, each commit has \i{one or more parents}. Correspondingly, the whole
history of a branch isn't just a linear sequence of commits going backwards
from its head --- it's the \i{set} of all parent commits. Topologically,
commits form not just a tree, but a \i{graph}, specifically an awesome
mathematical structure called a \i{directed acyclic graph} or DAG. It's not
worth getting into them here, but they're a very useful reasoning device for
certain problems. Uncoincidentally, DAGs are also the underlying formalism
for the legendary Unix tool \t{make}.

The \cmd{merge} command lets you create \i{merge commits}, which are those
that have more than one parent. Say you have a main branch, \s{master}, and a
side branch, \s{fix-typos}. The branches have \i{diverged} if their histories are
disjoint sets of commits: that is, if \s{master} has commits that are not in
\s{fix-typos}, and \s{fix-typos} has commits that are not in \s{master}. If we
\i{merge fix-typos into master}, that means that we're updating \s{master} to a
merge commit that unifies the two histories. After that point, \s{fix-typos} is
\i{merged into master}, in the sense that the set of commits in its history is
a subset of those in the history of \s{master}.

Yikes. Okay. What does this mean in practice? Let's merge your alternate line
of development into master:

\begin{typeme}
git checkout master & Switch to master. \\
git merge take2 & Merge the two. \\
./indict \p{some words} & Verify that your name and FP rate are printed.
\end{typeme}

The \cmd{merge} will prompt you to write a message for the merge commit;
unless you're working in a sophisticated project, you can usually just leave
it with the default.

That seemed straightforward enough. But, what if the \s{master} and
\s{fix-typos} branches had both modified the same part of the same file in
different ways? This is the dreaded \i{merge conflict}.

In practice, \git\ doesn't know how your software actually works, so the only
way to resolve a conflict is through human intervention. If a conflict arises,
\git\ will leave your working tree in a special funky state, with your files
modified to indicate where the conflicts are. You must decide how to resolve
the conflicts, then mark them as dealt with using \cmd{add}, and then finally
\cmd{commit} when everything is fixed. Things are a little bit simpler than
you might fear since the various commands will tell you the necessary steps as
you go through them.

\end{document}
