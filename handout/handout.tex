\documentclass[letterpaper,12pt,titlepage,twoside]{article}
\input setup

\title{A Laboratory Introduction to \git}
\author{P. K. G. Williams (\href{mailto:peter@newton.cx}{peter@newton.cx})}
\date{\today}

\begin{document}
\maketitle

\section*{Introduction\markboth{Introduction}{}}

Welcome to the \git\ lab! This manual aims to help you learn the fundamentals
of this awesome tool by walking you through some exercises that demonstrate
its everyday functionality. Along the way we'll discuss some of its underlying
principles and demonstrate some basic Unix shell skills too. We should note
that we're assuming that you've already been given a broad overview of what
\git\ is, and why you might want to use it.

Learning \git\ is like learning an instrument, or a language. There are
certain concepts to master, but there's also just a lot of practice involved:
repeating certain motions so that they become automatic. When it comes to
computers, Unix pros talk about \i{finger memory}: I can type out \t{git
  commit -am} in my sleep. Of course, there's also the deeper appreciation of
the underlying concepts and esoteric possibilities that you gain as you use a
tool more and more. My assertion to you is that \i{time spent practicing
  \git\ will more than repay itself in the future}. If you're just starting
out as a programmer (\ie, you've written less than 100,000 lines of code or
so), some of its advantages won't be immediately obvious; for what it's worth,
the developer site \href{https://github.com/}{GitHub} has more than 4.5
million users and 6 million \git\ repositories. I've been doing this for 20
years, and if \git\ disappeared tomorrow the first thing I'd do is start
recreating it.

\i{This lab is best done with a partner.} Real-deal education research shows
that it's much faster for you to learn something when talking it over with a
partner rather than just staring at it by yourself. Getting back to the finger
memory thing, though, please try to switch off between who's ``driving'' the
keyboard and who's watching and commenting. It really does make a difference!

If you and your partner get stuck on something, trying asking the group next
to you, or Google. Your lab assistants are happy to help you out, of course,
but you'll learn more if you spend some time trying to solve problems on your
own. That being said, with computers sometimes things go wrong even if you've
done everything right --- if you see a truly strange error message,
particularly one associated with a non-\git\ command, it's probably better to
summon the lab assistants sooner rather than later.


\subsection*{Notation in this manual}

Important terminology will be introduced in \i{italics}. Computer-y words will
be written in a monospace font \t{like this}. Commands that you should type in
are presented with commentary this way, sometimes with parameters that you
need to figure out for yourself:

\begin{typeme}
echo hello world & Say hello. \\
echo \p{your name} & Say your name.
\end{typeme}

You shouldn't type the leading dollar sign, which is just meant to indicate a
generic terminal prompt, or the braces. The exercises are interspersed with
questions so that you can check your understanding. They're represented
thusly:

\fillme{0.4in}{What is your name?}

Well, that's all the preliminaries. Let's get started!


\section{git clone}

The first task is to set up a \i{git repository} to play with. This is the
directory containing your actual content (\ie, files) as well as \git's
supporting data. There are two commands to set up a repository: \t{git~init},
which creates a new, empty repository; and \t{git~clone}, which duplicates an
existing one. We'll use the latter so that we have some files to work with
right off the bat.

\begin{typeme}
cd & Go to home directory. \\
mkdir gitlab & Create work directory. \\
cd gitlab & Move into it. \\
git clone https://github.com/pkgw/bloomdemo.git & Clone an existing repository.
\end{typeme}

Let's see what just happened:

\begin{typeme}
ls & Examine files. \\
cd \p{dirname} & Enter repository directory. \\
ls & Examine files again. \\
ls -la & Detailed listing of files.
\end{typeme}

By the way, in the final command above, the letter after the dash is an ell,
not a one.

\fillme{0.4in}{Where do you think \git's supporting data are stored?}

It's worth emphasizing that this cloned repository is both self-contained and
self-sufficient. You can do anything you want to it without having to talk to
\textsf{GitHub} again (without even needing an internet connection, in fact),
and nothing you do will affect the \textsf{GitHub} version unless you
explicitly attempt to synchronize the two. (Which is a vitally important
process for collaborative work, but not something that we're going to worry
about for a little while.)

You can see a gory listing of \git's housekeeping files with:

\typeone{find . -print}{Print all file names.}

Here, \t{find} is a Unix command that you may not be familiar with; there will
likely be more in the coming pages. If you'd like to learn more about a
command, you can try reading its manual page:

\begin{typeme}
man find & Learn about \t{find}. \\
man man & Learn about \t{man}.
\end{typeme}

\ldots\ although Unix manual pages are notoriously uneven in their quality.
(This is especially true regarding \git\ itself, unfortunately.) Google is
often a better resource for beginners. The information on the
\href{http://stackexchange.com/}{StackExchange.com} family of websites is
usually very helpful.


\section{git log}

At its core, \git\ just stores a bunch of files, and remembers the changes
made to them. Unsurprisingly, one of the fundamental \git\ commands lets you
see those changes. It's called \t{git~log}. You're not very likely to use this
command frequently in your early days, but it can be helpful for orienting
yourself if you've just downloaded an unfamiliar codebase.

\typeone{git log}{Show log of changes.}

When you run \t{git~log}, you enter a special subprogram called the \i{pager}.
The pager is a tool for navigating lengthy textual output that offers more
features than your terminal, and \git\ uses it extensively. Under default
settings, your pager is a Unix command called \t{less}, which is mainly
controlled by commands that are single keystrokes. Among them are:

\begin{center}
\begin{tabular}{>{\ttfamily}cl}
\rmfamily\i{Key} & \i{Effect} \\ \hline
q & Quit. \\
\rmfamily(Arrow keys) & Navigate as you'd expect. \\
< & Go to the top. \\
> & Go to the bottom. \\
/ & Search (type in query, then hit Enter). \\
n & Go to next search result. \\
N & Go to previous search result. \\
? & Print help information.
\end{tabular}
\end{center}

As a side note, the search command above uses a special formalism called
\i{regular expressions} or \i{regexes} for matching text. In general, you can
just type what you're looking for and the right thing will happen. You will
find that \i{many} Unix tools use regexes; they are just one of the many
interlocking technologies that constitute the overall Unix ecosystem.

\fillme{0.4in}{On what date was the very first commit made in this
  repository?}

You'll see that the output of \t{git~log} is a series of \i{commits}, each
associated with an author, a date, and a \i{commit message}. Each commit also
has a \i{commit identifier}, which is the 40-character string of gibberish.

\fillme{0.4in}{Find a commit whose message contains the word ``consuming.'' On
  what date was it made?}

An important aspect of \git\ is that every distinct commit in the universe has
a unique identifier.

\fillme{1.5in}{(Optional.) Commit identifiers are 40-character hexadecimal
  strings, with each character having 16 possible values (0--9, a--f). If you
  made one new commit every second, about how many Hubble times would need to
  elapse before you used all possible identifiers? The Hubble time is about
  $4.3 \times 10^{17}$~s, and $2^{10} \approx 10^3$.}

The \t{git~log} command can also show you which files were changed in each
commit. It presents this information in a compact form called a \i{diffstat}
that we'll see more of later. It shows how many lines were added and removed
from each file.

% NOTE that we have to do something funky for the double dash! We can't just
% auto-verbatim the command since I want to use things like my \p{} macro.
\typeone{git log -{}-stat}{Show log, with change statistics.}

\fillme{0.4in}{In the most recent commit to modify the file \t{INSTRUCTIONS},
  how many lines were added? How many removed?}


\end{document}
